{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    table: \"table\",\n    thead: \"thead\",\n    tr: \"tr\",\n    th: \"th\",\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    code: \"code\",\n    pre: \"pre\",\n    h3: \"h3\",\n    em: \"em\",\n    blockquote: \"blockquote\",\n    br: \"br\",\n    ul: \"ul\",\n    li: \"li\"\n  }, _provideComponents(), props.components), {Quote, TimeQuizChooser, CheckResults, CanvaEmbed} = _components;\n  if (!CanvaEmbed) _missingMdxReference(\"CanvaEmbed\", true);\n  if (!CheckResults) _missingMdxReference(\"CheckResults\", true);\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  if (!TimeQuizChooser) _missingMdxReference(\"TimeQuizChooser\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Hi!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"As software engineers, we all rely on the notion of time: a crucial\\nconcept in ensuring that events in our programs follow a chronological\\norder. Yet, invoking a simple call to “get the current time” can\\npotentially yield unexpected results and lead to unforeseen consequences\\nif not used correctly. Moreover, the invariants about time we observe on\\nour local development machine may not necessarily hold in the cloud, or\\nin any distributed system.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"In this article, I’ll go through the different ways we can obtain the\\ncurrent time in our programs, and present cases where our intuitions and\\nexpectations of time from these clocks may mislead us at best or cause\\ncatastrophic failures at worst.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/time/time_1.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quote, {\n      quote: \"What would be the biological reality of planet earth rotating once every\\neighteen hours instead of twenty-four? You have less time, but you have more days\\nin the year. So there’s a sense of losing something, and also gaining something.\\nWith an 18-hour clock there’s a lot more yesterdays.\",\n      attribution: \"Untitled (Clock) 2014\"\n    }), \"\\n\", _jsx(_components.table, {\n      children: _jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"⚠️\"\n          }), _jsx(_components.th, {\n            children: \"This article is illustrated with examples of code in Java. However, most of the content of this article is applicable to any language or runtime.\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"your-local-clocks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#your-local-clocks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Your local clocks\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let me start by asking you six questions. Here is a set of code\\nsnippets. Is it possible that the expression passed to \", _jsx(_components.code, {\n        children: \"isThisPossible\"\n      }), \"\\nis true? Take a guess.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      className: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq1\"\n        }), \"1. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\\nisThisPossible(t2 - t1 == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q1\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq2\"\n        }), \"2. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\\nisThisPossible(t2 - t1 == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q2\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq3\"\n        }), \"3. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\\nisThisPossible(t2 < t1);\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q3\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq4\"\n        }), \"4. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t2\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\\nisThisPossible(t2 < t1);\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q4\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq5\"\n        }), \"5. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.currentTimeMillis();\\n\\nisThisPossible(t1 < \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q5\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          id: \"aq6\"\n        }), \"6. Is this possible?\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"t1\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" System.nanoTime();\\n\\nisThisPossible(t1 < \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \");\\n\"]\n      })\n    }), \"\\n\", _jsx(TimeQuizChooser, {\n      id: \"q6\"\n    }), \"\\n\", _jsx(CheckResults, {}), \"\\n\", _jsx(_components.p, {\n      children: \"Was the result surprising? My sincere kudos if it was not. The next\\nsection of the article will explain why certain behaviour can or can not\\nbe observed.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But why do we even care? Very often we don’t need to, but the snippets\\nof code where the business logic relies on the observed timestamps are\\ntypically critical pieces of infrastructure code where correctness is a\\nmust. False assumptions in these parts of the code can lead to huge\\nincidents. This, for instance, happened to \", _jsx(_components.a, {\n        href: \"https://blog.cloudflare.com/how-and-why-the-leap-second-affected-cloudflare-dns/\",\n        children: \"Cloudflare in\\n2017\"\n      }), \",\\nwhere the root cause \\\"was the belief that time cannot go backwards\\\".\\nCloudflare is one of the few companies that openly publishes incident\\nreports, but it’s not uncommon to suffer from such false assumptions, as\\na few Google searches can confirm, and we can all learn from these\\nmistakes. To understand why certain clocks behave in a certain way, we\\nfirst need to understand what properties different clocks can give us.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"monotonicity\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#monotonicity\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Monotonicity\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first property is monotonicity. A monotonically increasing function\\nmeans that for every subsequent invocation of such a function the\\nproduced value is never smaller than any of the previous values. So, a\\nmonotonic clock is a clock that never goes backwards. Sadly, and\\nsurprisingly, this property is not a feature of many clocks.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"resolution\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#resolution\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Resolution\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Resolution is the second property. It is the smallest observable\\ndifference between two clock ticks. The resolution of a simple\\nmechanical watch with a second hand is one second. When you’re staring\\nat the watch, the meaningful watch hand position can be at 12 seconds or\\n13 seconds, but never 12 and a half.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"latency\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#latency\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Latency\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Very often latency is overlooked when we’re talking about clocks, but\\nit’s quite important when we’re considering other properties like\\nresolution. For instance, it doesn’t matter if you have the most precise\\natomic watch on your hand with picosecond resolution ‒ if I ask you what\\ntime it is and it takes you roughly a second, sometimes less, sometimes\\nmore, to take a look and respond, all of this precision fades away.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, what properties do Java clocks have, and how do they apply to the\\nquestions that we looked at the beginning?\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"clocks-on-the-wall\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#clocks-on-the-wall\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Clocks on the wall\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let’s start with \", _jsx(_components.code, {\n        children: \"System.currentTimeMillis()\"\n      }), \". Usually, the best place\\nto start the exploration is the documentation written in the Javadoc,\\nand there is a lot there to take in. Here is an excerpt of what is\\nimportant to us right now.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/System.java#l375\",\n            children: \"Javadoc\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-comment\",\n          children: [\"/**\\n * Returns the current time in milliseconds. Note that\\n * while the unit of time of the return value is a millisecond,\\n * the granularity of the value depends on the underlying\\n * operating system and may be larger.  For example, many\\n * operating systems measure time in units of tens of\\n * milliseconds.\\n *\\n * ...\\n *\\n * \", _jsx(_components.span, {\n            className: \"hljs-doctag\",\n            children: \"@return\"\n          }), \"  the difference, measured in milliseconds, between\\n *          the current time and midnight, January 1, 1970 UTC.\\n */\"]\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"native\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"currentTimeMillis\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As we can see, the clock provides us with a millisecond precision value\\nbut the actual resolution depends on the operating system. Moreover, if\\nwe measure the latency by measuring the execution time, it will be way\\nbelow 1 millisecond, so it’s maybe not a surprise that the answer to the\\n\", _jsx(_components.a, {\n        href: \"#aq1\",\n        children: \"first question\"\n      }), \" was yes.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But can it go backwards? The Javadoc doesn’t mention anything about\\nmonotonicity, so we need to dig deeper, and take a look at the\\nimplementation.\"\n    }), \"\\n\", _jsx(_components.table, {\n      children: _jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"⚠️\"\n          }), _jsx(_components.th, {\n            children: \"This article only explores the native implementation for Linux and MacOS. However, similar techniques can be applied to other operating systems as well.\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The method is native, so the implementation depends on the underlying\\nOS. The native implementation for Linux and MacOS look almost identical.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1204\",\n            children: \"Linux\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeMillis\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(&time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"  +  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/bsd/os_bsd.cpp#l893\",\n            children: \"MacOS\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeMillis\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(&time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"bsd error\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"  +  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The functions invoke exactly the same syscall, \", _jsx(_components.code, {\n        children: \"gettimeofday\"\n      }), \". The man\\npage can provide us with more info, but more importantly with some\\nvaluable notes:\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://man7.org/linux/man-pages/man2/gettimeofday.2.html\",\n            children: \"man page\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"\",\n        children: \"NAME\\n       gettimeofday, settimeofday - get / set time\\n\\nNOTES\\n       The time returned by gettimeofday() is affected by discontinuous\\n       jumps in the system time (e.g., if the system administrator manually\\n       changes the system time).  If you need a monotonically increasing\\n       clock, see clock_gettime(2).\\n\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As noted above, the time is affected by discontinuous jumps in the\\nsystem time, which could be backwards, hence the clock is not monotonic.\\nThe answer to the \", _jsx(_components.a, {\n        href: \"#aq3\",\n        children: \"third question\"\n      }), \" was yes which does make sense:\\nif we change the current time to one hour ago, we still want\\n\", _jsx(_components.code, {\n        children: \"currentTimeMillis\"\n      }), \" to return current time, even though the definition\\nof the current time has changed. That’s why it’s often called wall-clock\\ntime, the clock on the wall can also jump back in time if we adjust it.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"the-nanos-of-the-current-time\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#the-nanos-of-the-current-time\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"The nanos of the current time\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The same exploration path can be taken for \", _jsx(_components.code, {\n        children: \"System.nanoTime()\"\n      }), \". Let’s\\nstart from the Javadoc which has even more intriguing details than the\\nprevious one; here is an excerpt.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/java.base/share/classes/java/lang/System.java#l394\",\n            children: \"Javadoc\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"/**\\n * Returns the current value of the running Java Virtual Machine's\\n * high-resolution time source, in nanoseconds.\\n *\\n * This method can only be used to measure elapsed time and is\\n * not related to any other notion of system or wall-clock time.\\n * The value returned represents nanoseconds since some fixed but\\n * arbitrary <i>origin</i> time (perhaps in the future, so values\\n * may be negative) ...\\n *\\n * <p>This method provides nanosecond precision, but not necessarily\\n * nanosecond resolution ...\\n *\\n * <p>The values returned by this method become meaningful only when\\n * the difference between two such values, obtained within the same\\n * instance of a Java virtual machine, is computed.\\n *\\n * ...\\n */\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"native\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"nanoTime\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \";\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Apparently, the time returned by this clock isn’t related to any\\nreal-world time; it can only be used to compare the timestamps within\\nthe same JVM instance, and it’s relative to an arbitrary “origin” which\\ncan be in the future, and therefore it might be negative – which answers\\nthe \", _jsx(_components.a, {\n        href: \"#aq3\",\n        children: \"sixth question\"\n      }), \". Similar to \", _jsx(_components.code, {\n        children: \"currentTimeMillis\"\n      }), \", this method\\nprovides nanosecond precision, but not necessarily nanosecond\\nresolution.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Nano time can only be used to measure time intervals, so it ought to be\\nmonotonic, right? Unfortunately, the Javadoc doesn’t say anything about\\nmonotonicity, so the next step is the implementation.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1301\",\n            children: \"Linux\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeNanos\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (os::\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"supports_monotonic_clock\"\n        }), \"()) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"struct\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"timespec\"\n        }), \" tp;\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = Linux::\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"clock_gettime\"\n        }), \"(CLOCK_MONOTONIC, &tp);\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status == \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"gettime error\\\"\"\n        }), \");\\n    jlong result = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(tp.tv_sec) * (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \") + \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(tp.tv_nsec);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" result;\\n  } \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" {\\n    timeval time;\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(&time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n    \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n    jlong usecs = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * (\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \") + \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \" * usecs;\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here comes the first surprise: nano time is indeed monotonic but\\n\", _jsx(_components.em, {\n        children: \"only\"\n      }), \" if the underlying operating system supports it. To be fair, any\\nmodern Linux server supports \", _jsx(_components.code, {\n        children: \"CLOCK_MONOTONIC\"\n      }), \"; there are, however, some\\n\", _jsx(_components.a, {\n        href: \"https://stackoverflow.com/a/51345008/1542319\",\n        children: \"rare situations\"\n      }), \" in which\\nit might not hold true.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/bsd/os_bsd.cpp#l893\",\n            children: \"MacOS\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeNanos\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" tm = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"mach_absolute_time\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" now = (tm * Bsd::_timebase_info.numer) / Bsd::_timebase_info.denom;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" prev = Bsd::_max_abstime;\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (now <= prev) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" prev;   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// same or retrograde time;\"\n        }), \"\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"const\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"uint64_t\"\n        }), \" obsv = Atomic::\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"cmpxchg\"\n        }), \"(now, &Bsd::_max_abstime, prev);\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(obsv >= prev, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"invariant\\\"\"\n        }), \");   \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Monotonicity\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// If the CAS succeeded then we're done and return \\\"now\\\".\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// If the CAS failed and the observed value \\\"obsv\\\" is >= now then\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// we should return \\\"obsv\\\".  If the CAS failed and now > obsv > prv then\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// some other thread raced this thread and installed a new value, in which case\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// we could either (a) retry the entire operation, (b) retry trying to install now\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// or (c) just return obsv.  We use (c).   No loop is required although in some cases\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// we might discard a higher \\\"now\\\" value in deference to a slightly lower but freshly\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// installed obsv value.   That's entirely benign -- it admits no new orderings compared\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// to (a) or (b) -- and greatly reduces coherence traffic.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// We might also condition (c) on the magnitude of the delta between obsv and now.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// Avoiding excessive CAS operations to hot RW locations is critical.\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// See https://blogs.oracle.com/dave/entry/cas_and_cache_trivia_invalidate\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" (prev == obsv) ? now : obsv;\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The first thing that stands out is the giant wall of comments. As\\nsoftware engineers, we know that if there is a long comment then\\nsomething dodgy must be going on. Indeed, the comment is quite\\ninteresting. The call to\\n\", _jsx(_components.a, {\n        href: \"https://opensource.apple.com/source/Libc/Libc-320.1.3/i386/mach/mach_absolute_time.c.auto.html\",\n        children: _jsx(_components.code, {\n          children: \"mach_absolute_time\"\n        })\n      }), \"\\nuses the \", _jsx(_components.a, {\n        href: \"https://en.wikipedia.org/wiki/Time_Stamp_Counter\",\n        children: \"RDTSC\"\n      }), \"\\ninstruction underneath which can \", _jsx(_components.em, {\n        children: \"potentially\"\n      }), \" lead to non-monotonic\\nbehaviour on machines with multiple CPU sockets, which recently span up\\nanother thought-provoking discussion on the \", _jsx(_components.a, {\n        href: \"https://groups.google.com/forum/#!topic/mechanical-sympathy/7WnH37dA6Yc\",\n        children: \"mechanical\\nsympathy\"\n      }), \"\\nmailing list.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, at least, we can be confident that nano time is always monotonic on\\nMacOS, right? Actually, it depends on the JVM version. The code listed\\nabove was introduced in JDK9 in\\n\", _jsx(_components.a, {\n        href: \"https://bugs.openjdk.java.net/browse/JDK-8040140\",\n        children: \"JDK-8040140\"\n      }), \" and\\nbackported to JDK8. Before, all you could hope for was non-monotonic\\ntime which provided at best microsecond resolution because\\n\", _jsx(_components.code, {\n        children: \"gettimeofday\"\n      }), \" was used. If we run some\\n\", _jsx(_components.a, {\n        href: \"https://shipilev.net/blog/2014/nanotrusting-nanotime/#_latency\",\n        children: \"benchmarks\"\n      }), \",\\nwe’ll see that the latency for these calls can be as small as 30ns, so\\nsuddenly the answer to the \", _jsx(_components.a, {\n        href: \"#aq2\",\n        children: \"second\"\n      }), \" and the \", _jsx(_components.a, {\n        href: \"#aq4\",\n        children: \"fourth\"\n      }), \"\\nquestions is true, or rather \\\"it depends\\\".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"when-milliseconds-are-not-enough\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#when-milliseconds-are-not-enough\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"When milliseconds are not enough\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The microsecond precision in the case of \", _jsx(_components.code, {\n        children: \"gettimeofday\"\n      }), \" is much more\\nthan \", _jsx(_components.code, {\n        children: \"System.currentTimeMillis()\"\n      }), \" can give us, but in the process of\\nconversion precision is lost.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-cpp\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [\"jlong \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"os::javaTimeMillis\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \"]\n        }), \"{\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" status = \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"gettimeofday\"\n        }), \"(&time, \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"NULL\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"assert\"\n        }), \"(status != \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"-1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_sec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \"  +  \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"jlong\"\n        }), \"(time.tv_usec / \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \");\\n                                                      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ^^ precision loss\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The OS can give us additional information which we violently discard in\\norder to fit it into a single long. What if we really want to know these\\nmicros? In JDK 8, the new JSR 310 arrived which made it possible to\\nobtain an instance of \", _jsx(_components.code, {\n        children: \"Instant\"\n      }), \" class which contains the number of\\nseconds since the epoch and the number of nanoseconds since the last\\nsecond started.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"https://jcp.org/en/jsr/detail?id=310\",\n            children: \"JSR 310: Date and Time API\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Instant\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"instant\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" Clock.systemUTC().instant();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"epochSecond\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" instant.getEpochSecond();\\n\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"nanoSinceSecond\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" instant.getNano();\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Finally, all Java developers got access to wall-clock time with high\\nprecision, right? Not so fast, if we take a look at the implementation\\nin JDK8, we’ll find out that it simply delegates straight to\\n\", _jsx(_components.code, {\n        children: \"System.currentTimeMillis()\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/time/Clock.java#l469\",\n            children: \"JDK8\\nClock\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Override\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"long\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"millis\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" System.currentTimeMillis();\\n}\\n\", _jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@Override\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" Instant \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"instant\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"()\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Instant.ofEpochMilli(millis());\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Evidently, this is not optimal and there is a corresponding issue\\n\", _jsx(_components.a, {\n        href: \"https://bugs.openjdk.java.net/browse/JDK-8068730\",\n        children: \"JDK-8068730\"\n      }), \" which\\nhas already been resolved and as a result, the precision was increased.\\nIt requires an update to JDK9+ where the method delegates to a native\\ncall with the following implementation on Linux. Assuming that your OS\\ncan provide microsecond resolution, this clock is a great example of a\\nclock with nanosecond precision, but only microsecond resolution.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: _jsx(_components.a, {\n            href: \"http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/hotspot/os/linux/os_linux.cpp#l1211\",\n            children: \"JDK9+\\nClock\"\n          })\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"void\"\n        }), \" os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\\n  timeval time;\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"status\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" gettimeofday(&time, NULL);\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"assert\"\n        }), \"(status != -\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"linux error\\\"\"\n        }), \");\\n  seconds = jlong(time.tv_sec);\\n  nanos = jlong(time.tv_usec) * \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1000\"\n        }), \";\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"time-exchange\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#time-exchange\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Time exchange\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The possibility to get the current wall-clock time with microsecond\\nresolution is great, but is needed often? One of the reasons to use\\nwall-clock time is to be able to relate an event that happened on one\\nmachine to another event that happened on a different machine, or more\\nprecisely, to decide on the order of these events. The events can be\\nvery different in nature. Some of them might not be very critical, like\\nthe timestamp on a log line, but some of them must be correct, like when\\nthere is a conflict in a database due to two values being written\\nconcurrently and timestamps are used to determine which event was last.\\nThis strategy is called Last Write Wins, or simply LWW.\"\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZmyL_mRw\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"On the slides above, two clients Alice and Bob are trying to write\\nsimultaneously into an eventually consistent webscale database with two\\nnodes. While the first value written by Alice was successfully\\nsynchronized, Alice’s second write happened to be at approximately the\\nsame time as Bob’s. In this situation, the database must resolve the\\nconflict so that the data is consistent between all of the nodes. In the\\ncase of LWW, the latest write will be chosen by comparing the timestamps\\nof each write. LWW works perfectly if the clocks are perfectly\\nsynchronised, however, if the clocks are poorly synchronised and the\\nclock of the first node has drifted ahead of the second node, LWW\\nbecomes Lucky Write Wins – the client connected to the lucky node always\\nwins the conflict.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"ntp\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#ntp\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"NTP\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The standard approach to make sure that the clocks on different nodes in\\nthe cluster are synchronized is to use Network Time Protocol (NTP). Not\\nonly does NTP help synchronise clocks, it also helps propagate a leap\\nsecond flag. Leap second is an occasional event where an additional\\nsecond is introduced in between 23:59:59 of a chosen day and 00:00:00 of\\nthe following day. It’s often implemented as playing the same second\\ntwice which from the observer’s point of view might look like a jump 1\\nsecond back in time. The last leap second was introduced on the 31st of\\nDecember 2016 which resulted in the above-mentioned DNS incident.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/time/time_2.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The conventional way of dealing with leap seconds is \\\"leap smearing\\\".\\nThe NTP server which is responsible for leap smearing can distribute the\\nadditional second amongst 12 hours before and 12 hours after the second\\nis introduced. The wall-clock time during these 24 hours is ticking\\nslower and every second is 1/86400 longer which might be surprising,\\nhowever less surprising than a jump back in time. The catch is that not\\nmany NTP servers support leap smearing, the public NTP servers most\\ndefinitely don’t.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The major cloud providers,\\n\", _jsx(_components.a, {\n        href: \"https://developers.google.com/time/smear\",\n        children: \"Google\"\n      }), \" and\\n\", _jsx(_components.a, {\n        href: \"https://aws.amazon.com/blogs/aws/look-before-you-leap-the-coming-leap-second-and-aws/\",\n        children: \"AWS\"\n      }), \"\\nboth provide NTP services with leap smearing support. If your\\napplication is hosted on a platform that provides an NTP service and you\\ncare about clock synchronisation it’s worthwhile checking that NTP\\nsynchronisation is set up with the provider’s NTP service. Not only can\\nit help avoid the nasty consequences of applying leap seconds naïvely,\\nbut it also dramatically decreases the synchronisation error since the\\nnetwork latency is typically much lower within a single datacenter.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.em, {\n          children: \"AWS NTP with chrony\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsx(_components.code, {\n        className: \"hljs language-shell\",\n        children: \"sergey:~$ chronyc sources -v\\n210 Number of sources = 9\\n\\n  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.\\n / .- Source state '*' = current synced, '+' = combined , '-' = not combined,\\n| /   '?' = unreachable, 'x' = time may be in error, '~' = time too variable.\\n||                                                 .- xxxx [ yyyy ] +/- zzzz\\n||      Reachability register (octal) -.           |  xxxx = adjusted offset,\\n||      Log2(Polling interval) --.      |          |  yyyy = measured offset,\\n||                                \\\\     |          |  zzzz = estimated error.\\n||                                 |    |           \\\\\\nMS Name/IP address         Stratum Poll Reach LastRx Last sample\\n===============================================================================\\n^* 169.254.169.123               3  10   377   433    -25us[  -36us] +/-  356us\\n\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Using a local NTP server can reduce the clock drift down to milliseconds\\nor even microseconds in the best case, but what is the worst case? There\\nis not much research on this topic, however some notable results were\\nmentioned in the Google Spanner paper.\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsxs(_components.p, {\n        children: [\"Between synchronizations, a daemon advertises a slowly increasing time\\nuncertainty. ε is derived from conservatively applied worst-case local\\nclock drift. ε also depends on time-master uncertainty and\\ncommunication delay to the time masters. In our production\\nenvironment, ε is typically a sawtooth function of time, varying from\\nabout 1 to 7 ms over each poll interval. ε̅\\u000f is therefore 4 ms most of\\nthe time. The daemon’s poll interval is currently 30 seconds, and the\\ncurrent applied drift rate is set at 200 microseconds/second, which\\ntogether accounts for the sawtooth bounds from 0 to 6 ms.\", _jsx(_components.br, {}), \"\\n\", \"—  Spanner: Google’s Globally-Distributed Database\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"logical-conclusion\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#logical-conclusion\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Logical conclusion\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even if the monitoring in our cluster shows that the clocks are\\nsynchronised with microsecond precision, we need to be cautious and\\nshouldn’t rely on this in our software if a failure of this assumption\\nis unacceptable. So, if a failure is unacceptable and we need to know\\nthe order of the events in a distributed system, is there anything we\\ncan do? As always, there is a number of solutions suggested by academia.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"lamport-clocks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#lamport-clocks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Lamport clocks\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"What we need is a reliable replacement for our system clocks, so that\\nfor every two events \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" we can say that either \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" happened\\nbefore \", _jsx(_components.em, {\n        children: \"B\"\n      }), \", or \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" happened before \", _jsx(_components.em, {\n        children: \"A\"\n      }), \". Such order between events is\\ncalled total order. In the \", _jsx(_components.a, {\n        href: \"https://lamport.azurewebsites.net/pubs/time-clocks.pdf\",\n        children: \"\\\"Time, Clocks, and the Ordering of Events in\\na Distributed\\nSystem\\\"\"\n      }), \" paper\\nLeslie Lamport described the \\\"happens before\\\" relation and logical\\nclocks that can be used to define total order for a set of events using\\nthe following algorithm.\"]\n    }), \"\\n\", _jsxs(\"table\", {\n      children: [_jsxs(\"colgroup\", {\n        children: [_jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        }), _jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        })]\n      }), _jsxs(\"tbody\", {\n        children: [_jsxs(\"tr\", {\n          class: \"odd\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Sending a message\"\n            })\n          }), \"\\n\", _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Receiving a message\"\n            })\n          })]\n        }), _jsxs(\"tr\", {\n          class: \"even\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"time = time + 1;\\nsend(message, time);\\n\"\n                })\n              })\n            })\n          }), _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"(message, ts) = receive();\\ntime = max(ts, time) + 1;\\n\"\n                })\n              })\n            })\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Every actor, in this case, Alice and Bob, will maintain a shared view of\\nthe current time by maintaining a \", _jsx(_components.code, {\n        children: \"time\"\n      }), \" counter which increases every\\ntime a message is sent, and when a message is received, the \", _jsx(_components.code, {\n        children: \"time\"\n      }), \" is\\nalways bigger than the last observed counter. That way if Alice updates\\nthe Database as shown below with the value 2 and tells Bob about the\\nlast known state, Bob’s final write carries with it the knowledge of\\nseeing Alice’s counter, so it’s chosen as the final state of the\\ndatabase.\"]\n    }), \"\\n\", _jsx(_components.table, {\n      children: _jsx(_components.thead, {\n        children: _jsxs(_components.tr, {\n          children: [_jsx(_components.th, {\n            children: \"❗️\"\n          }), _jsx(_components.th, {\n            children: \"In the slides below, Alice tells Bob the value she wrote to the first node. Alternatively, Bob could have read the same value from the first node, leading to the same result – Alice and Bob don't have to communicate directly.\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnGWHlAU\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This works perfectly as long as we need to define some total order of\\nthe events in the system which captures the causality. It’s important to\\nnote that having total order means that concurrent events will be\\nordered in some way, not necessarily the most logical way. On the slides\\nbelow, Alice never talked to Bob, but her counter is bigger which leads\\nto her write being chosen in the case of a conflict.\"\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnC8PNnM\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"vector-clocks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#vector-clocks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Vector clocks\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"To deal with truly concurrent events, we need a new definition or order\\nwhich is able to express the situation in which events can happen\\nconcurrently. Such order is called partial order. Basically, this means\\nthat for any two events \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"B\"\n      }), \", it’s possible to say whether \", _jsx(_components.em, {\n        children: \"A\"\n      }), \"\\nhappened before \", _jsx(_components.em, {\n        children: \"B\"\n      }), \", \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" happened before \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" or \", _jsx(_components.em, {\n        children: \"A\"\n      }), \" and \", _jsx(_components.em, {\n        children: \"B\"\n      }), \" happened\\nconcurrently. To determine partial order the following algorithm can be\\nused this, where every actor has a separate time counter, and keeps\\ntrack of the latest timestamp of any other actor in the system.\"]\n    }), \"\\n\", _jsxs(\"table\", {\n      children: [_jsxs(\"colgroup\", {\n        children: [_jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        }), _jsx(\"col\", {\n          style: {\n            width: \"50%\"\n          }\n        })]\n      }), _jsxs(\"tbody\", {\n        children: [_jsxs(\"tr\", {\n          class: \"odd\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Sending a message\"\n            })\n          }), \"\\n\", _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"p\", {\n              children: \"Receiving a message\"\n            })\n          })]\n        }), _jsxs(\"tr\", {\n          class: \"even\",\n          children: [_jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"V[myId] = V[myId] + 1\\nsend(message, V);\\n\"\n                })\n              })\n            })\n          }), _jsx(\"td\", {\n            style: {\n              textAlign: \"left\"\n            },\n            children: _jsx(\"pre\", {\n              class: \"pseudocode\",\n              children: _jsx(_components.pre, {\n                children: _jsx(_components.code, {\n                  className: \"\",\n                  children: \"(message, Vr) = receive();\\nfor (i, v) in Vr {\\n    V[i] = max(V[i], v);\\n}\\nV[myId] = V[myId] + 1;\\n\"\n                })\n              })\n            })\n          })]\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The algorithm was described in 1988, and later using vector clocks for\\nconflict resolution in a database was described in the Dynamo paper. On\\nthe following slides, Alice keeps track of her own time counter as well\\nas Bob’s last known time counter. That way when Alice sends a message to\\nBob, he updates his counters and the next message sent to the database\\nis chosen during the conflict resolution because each component of Bob’s\\ntime vector is larger than the respective component of the previous\\nvector.\"\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnKp0nOE\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When there is a real conflict, vector clocks can help to determine\\nwhether the events were truly concurrent. In the scenario below, two\\nnodes end up with the events, \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" and \", _jsx(_components.code, {\n        children: \"[0, 1]\"\n      }), \" which cannot be\\nordered. In this situation, the database can keep both values, and\\nreturn them the next time it is read, to let either Alice or Bob decide\\nwhich one to keep so that the data is not lost.\"]\n    }), \"\\n\", _jsx(CanvaEmbed, {\n      designID: \"DADZnBQkwxE\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"These properties, however, do not come for free. The metadata needs to\\nbe exchanged with every message, and multiple versions need to be\\nstored. After all, some databases, like Cassandra don’t use vector\\nclocks \", _jsx(_components.a, {\n        href: \"https://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks\",\n        children: \"for a reason\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"conclusion\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#conclusion\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Conclusion\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"System.nanoTime()\"\n          }), \" for measuring time intervals\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"System.currentTimeMillis()\"\n          }), \" for obtaining wall-clock time\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Use \", _jsx(_components.code, {\n            children: \"Clock.systemUTC().instant()\"\n          }), \" for getting wall-clock time with ns\\n\", _jsx(_components.em, {\n            children: \"precision\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Not every clock can give you the resolution you want even if its\\nprecision is high\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"The wall-clock time can be off by dozens of milliseconds (or more, or\\nless)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Use NTP from your cloud provider if time synchronisation matters\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Logical clocks might be more appropriate than the real clocks but they\\nhave associated costs\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"thanks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#thanks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Thanks\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"You for reading this article\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Uri Baghin for reviewing the article\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"references\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#references\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"References\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://shipilev.net/blog/2014/nanotrusting-nanotime/\",\n          children: \"Nanotrusting the Nanotime\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.usenix.org/system/files/conference/osdi12/osdi12-final-16.pdf\",\n          children: \"Spanner: Google’s Globally-Distributed Database\"\n        })\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/set-time.html\",\n          children: \"AWSNTP\"\n        }), \" / \", _jsx(_components.a, {\n          href: \"https://developers.google.com/time/\",\n          children: \"Google NTP\"\n        })]\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.youtube.com/watch?v=un1AHZBgFfk\",\n          children: \"Video PWLSF - Bryan Fink on \\\"A Brief History of NTP Time: Memoirs of an Internet Timekeeper\\\"\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://ieeexplore.ieee.org/abstract/document/103043/\",\n          children: \"Internet time synchronization: the network time protocol\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.cloudflare.com/how-and-why-theleap-second-affected-cloudflare-dns/\",\n          children: \"How and why the leap second affected Cloudflare DNS\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://aphyr.com/posts/299-the-trouble-with-timestamps\",\n          children: \"The trouble with timestamps\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://lamport.azurewebsites.net/pubs/time-clocks.pdf\",\n          children: \"Time, Clocks, and the Ordering of Events in a Distributed System\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://zoo.cs.yale.edu/classes/cs426/2012/lab/bib/fidge88timestamps.pdf\",\n          children: \"Timestamps in Message-Passing Systems That Preserve the Partial Ordering\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://blog.rapid7.com/2014/03/14/synchronizing-clocksin-a-cassandra-cluster-pt-1-the-problem/\",\n          children: \"Synchronizing Clocks In a Cassandra Cluster\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks\",\n          children: \"Why Cassandra doesn’t need vector clocks\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.allthingsdistributed.com/files/amazondynamo-sosp2007.pdf\",\n          children: \"Dynamo: Amazon’s Highly Available Key-value Store\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://basho.com/posts/technical/why-vector-clocks-are-easy/\",\n          children: \"Why Vector Clocks Are Easy\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"http://basho.com/posts/technical/why-vector-clocks-are-hard/\",\n          children: \"Why Vector Clocks Are Hard\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"discuss-on\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#discuss-on\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Discuss on\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://twitter.com/SerCeMan/status/1128963307753287680\",\n          children: \"Twitter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://news.ycombinator.com/item?id=20173673\",\n          children: \"Hacker News\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://www.reddit.com/r/java/comments/bpc0im/the_matter_of_time/\",\n          children: \"Reddit\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"The matter of time()","description":"Empty","date":"2019-05-16"}},"frontMatter":{"title":"The matter of time()","description":"Empty","date":"2019-05-16"}},"__N_SSG":true}