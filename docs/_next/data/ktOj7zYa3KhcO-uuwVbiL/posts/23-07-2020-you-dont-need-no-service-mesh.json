{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components), {Quote} = _components;\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Hi!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Service meshes have attracted an enormous amount of hype around them.\\nWith at least a few talks about service meshes during each tech\\nconference, one can easily be convinced that having a service mesh in\\ntheir infrastructure is a must. However, hype isn’t a good indicator of\\nwhether the new shiny tech is the right solution for your problems. So\\nbelow, I’ll try to express an anti-hype opinion on service meshes to\\nhopefully make it less confusing when you want to decide whether you may\\nor may not need one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/servicemesh/rick.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quote, {\n      quote: \"There’s a lesson here, and I’m not going to be the one to figure it out.\",\n      attribution: \"Rick Sanchez\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"the-invention\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#the-invention\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"The invention\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let’s take a step back in history and take a look at one of the \", _jsx(_components.a, {\n        href: \"https://eng.lyft.com/envoy-7-months-later-41986c2fd443\",\n        children: \"early\\narticles\"\n      }), \" about\\nintroducing Envoy at Lyft.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"As it turns out, almost every company with a moderately-sized service\\noriented architecture is having the same problems that Lyft did prior\\nto the development and deployment of Envoy:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"An architecture composed of a variety of languages, each containing\\na half-baked RPC library, including partial (or zero)\\nimplementations of rate limiting, circuit breaking, timeouts,\\nretries, etc.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Differing or partial implementations of stats, logging, and ….\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While Envoy is not a service mesh by itself, the outlined problems\\ndescribe the exact reason why service meshes were invented. They add\\n“rate limiting, circuit breaking, …” and other reliability,\\nobservability, and security features to the services by enforcing the\\ncommunication to go through the service mesh proxies, a data plane.\\nAdditionally, they require a separate component, a control plane, to\\ncontrol the configuration.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, at this point, a lot of people miss the context in which\\nservice meshes were introduced. Service meshes are able to solve the\\nproblem not because it’s impossible to solve them in any other way.\\nThere are many battle-proof RPC libraries that take on the challenges of\\na separate data plane layer,\\n\", _jsx(_components.a, {\n        href: \"https://github.com/twitter/finagle\",\n        children: \"Finagle\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://github.com/grpc\",\n        children: \"gRPC\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://github.com/line/armeria\",\n        children: \"Armeria\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://github.com/apple/servicetalk\",\n        children: \"Servicetalk\"\n      }), \", to name a few.\\nAfter all, the very first service mesh - Linkerd 1.0 \", _jsx(_components.a, {\n        href: \"https://github.com/linkerd/linkerd\",\n        children: \"is powered by\\nFinagle\"\n      }), \". The RPC libraries will\\nneed a component which provides service discovery and configuration\\nmanagement to make it a true mesh. For instance, Zookeeper, or Consul, a\\ncomponent that service meshes call a control plane.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Why introduce a new concept to solve the problems that have been solved\\nbefore? The service mesh concept wasn’t introduced to address problems\\nthat hadn’t been addressed before but rather address them in a way that\\ndoesn’t require any modifications to the application code, which is\\nincredibly convenient when it’s hard to introduce an RPC layer into an\\nexisting heterogeneous microservice environment.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When you hear service mesh, Istio with Envoy might be the first thing\\nthat comes to mind, but it wasn’t the first service mesh to enter the\\nmarket. Linkerd authors who pioneered the space, described exactly this\\nsituation in the \", _jsx(_components.a, {\n        href: \"https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary\",\n        children: \"\\\"why is the service mesh necessary\\\"\"\n      }), \".\\nInterestingly, in many hype-y articles on the Internet this context is\\noften forgotten, or omitted.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Solving a problem well, even if it’s a problem that a lot of people\\nhave, doesn’t magically provide the tech with a lot of hype. There is\\nalways a sponsor behind it. I don’t know who the sponsor was here, and\\nI’m going to speculate, but it’s hard to sell an RPC library in the\\nworld where open source is a fundamental requirement. There is no clear\\nbusiness model there, that’s why most of the mature RPC libraries were\\nopen-sourced by large tech companies for which it’s not a part of the\\ncore business model. A library is just code, not a piece of\\ninfrastructure. Service meshes are a different story. It’s an isolated\\nnon-trivial piece of infrastructure. As a vendor, not only can you\\nprovide consultancy around the configuration and deployment, but you can\\nalso sell complete hosted solutions around it.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"disillusionments\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#disillusionments\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Disillusionments\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that we’ve established the problems, the solution, and most\\nimportantly, the context in which the solution was made, let’s take a\\nlook at the alternatives. The most obvious one, in the spirit of KISS,\\nis to use an RPC library for your preferred language. Here is where the\\ncontext is crucial: if you have a large fleet of services, each written\\nin its own language/ecosystem, and the only language that they share is\\nHTTP then having a single shared RPC library is going to be hard.\\nPerhaps, you’ve got a fabric of deployed and running services, but\\neveryone is afraid of touching them, no one knows how they work, and\\neach redeploy is an adventure. A service mesh is here to help you,\\nbecause at least you’ll be able to roll out new infrastructure features\\nto the mesh regularly.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"On the other hand, if you have a fleet of healthy services written in a\\nsingle application stack, then it’s a good idea to think twice before\\nintroducing a service mesh. By simply introducing or evolving a shared\\nRPC library, you’ll get the exact same benefits and avoid dealing with\\nthe downsides of maintaining service meshes. By studying the service\\nmesh limitations thoroughly, you can avoid finding yourself in the\\ntrough of disillusionment.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/servicemesh/curve.png\",\n        alt: \"Hype Cycle\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"different-ecosystem\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#different-ecosystem\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Different ecosystem\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The ecosystem of the service mesh of your choice will likely be\\ndifferent from the ecosystem of your services. Beautiful websites always\\nmake you believe that the solution is plug’n'play, always works and\\nnever goes down. In reality, sooner or later problems, bugs, quirks in\\nbehaviour will reveal themselves, as they always do. At that point,\\nyou’ll need to have engineers who work on the service-mesh’s ecosystem\\nwhich when it’s different from the main app, effectively limits the set\\nof people who can introduce changes or fix problems. This is likely to\\nreintroduce silos, which is against the whole DevOps spirit. Yes, having\\na DevOps team of engineers who are doing DevOps-y things \", _jsx(_components.a, {\n        href: \"https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/\",\n        children: \"is against\\nDevOps\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"unnecessary-overhead\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#unnecessary-overhead\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Unnecessary overhead\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Not only having a proxy in front of each service adds overhead (often\\nsignificant, talking about\\n\", _jsx(_components.a, {\n        href: \"https://istio.io/latest/docs/ops/deployment/performance-and-scalability/\",\n        children: \"90pt\"\n      }), \"\\nrather than 99pt in the performance summary \", _jsx(_components.a, {\n        href: \"https://www.infoq.com/presentations/latency-response-time/\",\n        children: \"doesn’t make software run\\nfaster\"\n      }), \") and\\nconsumes resources, but you also requires time (or rather a team of\\npeople) to manage them. Yes, it can help to make some of the tasks\\npotentially easier - yay, you can now add canary deployments with a few\\nlines of YAML to simple applications now. However, you still need to\\nmanage canary deployments of the proxies themselves which don’t have a\\nproxy in front of them. The problems just get pushed up the stack.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"limiting-your-architecture-to-what-the-proxy-supports\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#limiting-your-architecture-to-what-the-proxy-supports\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Limiting your architecture to what The Proxy supports.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As you’re reading this paragraph, HTTP/3 is slowly being rolled out to\\nthe Internet. It uses UDP as transport. Why use UDP rather than create a\\ncompletely new protocol you ask? That’s because anything but TCP and UDP\\nis simply “blocked” by the boxes, various proxies on the internet -\\nrouters, gateways, etc. This phenomenon got named\\n\", _jsx(_components.a, {\n        href: \"https://http3-explained.haxx.se/en/why-quic/why-ossification\",\n        children: \"ossification\"\n      }), \".\\nSo, only TCP or UDP are left is the practical chose, and even UDP is\\npartially blocked by various corporate proxies which slows down the\\nadoption.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even though your microservice environment is probably much smaller\\ncompared to the Internet, you can draw parallels with service meshes.\\nProxies can ossify your application architecture by limiting how your\\nservices talk to each other, and there is not much benefit in having\\nproxies if you can bypass them. Suppose you want to build a reactive\\napplication which is using RSocket over pure tcp? Or perhaps a\\nmessage-driven application using an actor model? Or maybe push the\\nperformance boundaries with Aeron? Not going to happen until the box in\\nthe middle becomes aware of the protocol.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"do-i-need-one\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#do-i-need-one\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Do I need one?\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What does it all mean for you as an engineer? The answer to whether you\\nneed to adopt the service mesh approach comes down to the state of the\\nmicroservice environment you’re trying to improve. As we have\\nestablished, compared to an RPC framework, service meshes allow you to:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Deploy the infra changes more often than deploying your services.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Introduce infra changes without touching the service code.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The point 1. is important when for whatever reason you can’t redeploy\\nyour services very often, e.g. maybe no one remembers how it’s done\\nanymore, or maybe there are other restrictions. The point 2. is\\nimportant when your stack is heterogeneous, e.g. some services are built\\nin Go, some in Java, some in Haskell, etc. Where are you on the interval\\nfrom a huge set of heterogeneous services with unknown deployment\\nschedules to a set of homogenous regularly deployed services defines\\nwhether a service mesh is the best solution for you.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"conclusion\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#conclusion\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Conclusion\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Service meshes have a lot of hype around them, and way too much in my\\nopinion. However, before committing to a piece of technology, it’s\\ncrucial to understand the problems it solves, and the context in which\\nthe solution was made. A service mesh is not an ultimate “good practice”\\nbut simply one of the patterns to solve a set of issues, and it’s quite\\na heavy one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than jumping on board, look carefully - the last thing you want\\nis to find out that you have invested in a solution for a problem that\\nyou don’t have. Service meshes are an amazing piece of tech solving a\\nwhole lot of problems. Not in every case, it is the best solution.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"thank-you-to\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#thank-you-to\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Thank you to\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"You for reading this article.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://twitter.com/ptuls\",\n          children: \"Paul Tune\"\n        }), \" for reviewing the article.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"references\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#references\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"References\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://eng.lyft.com/envoy-7-months-later-41986c2fd443\",\n          children: \"https://eng.lyft.com/envoy-7-months-later-41986c2fd443\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/linkerd/linkerd/\",\n          children: \"https://github.com/linkerd/linkerd/\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://servicemesh.io/\",\n          children: \"https://servicemesh.io/\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/\",\n          children: \"https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://http3-explained.haxx.se/en/why-quic/why-ossification\",\n          children: \"https://http3-explained.haxx.se/en/why-quic/why-ossification\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary\",\n          children: \"https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"discuss-on\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#discuss-on\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Discuss on\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://twitter.com/SerCeMan/status/1286242507664191488\",\n          children: \"Twitter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://news.ycombinator.com/item?id=25148642\",\n          children: \"Hacker News\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"You don't need no Service Mesh","description":"Empty","date":"2020-07-23"}},"frontMatter":{"title":"You don't need no Service Mesh","description":"Empty","date":"2020-07-23"}},"__N_SSG":true}