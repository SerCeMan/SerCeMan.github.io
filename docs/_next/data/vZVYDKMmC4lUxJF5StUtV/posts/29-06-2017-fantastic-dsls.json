{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    strong: \"strong\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {Quote} = _components;\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Hi!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kotlin is a very rich language. Unlike many other languages, it allows\\ndevelopers to create another language inside it. For example, to mimic\\nHTML syntax or to build a completely typed SQL query. But Kotlin’s power\\nisn’t limited to simple DSLs. With some Kotlin-fu, it’s possible to\\nwrite a DSL that allows manipulating untyped data structures in a typed\\nmanner. In this article, we’ll go through different ways to define DSL\\nin Kotlin, from very simple to fantastically powerful.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/kotlin_island.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quote, {\n      quote: \"Peter the Great at one time even considered moving the capital of\\nRussia to Kotlin Island, proof of the sovereign’s great affinity with\\nwater. This utopian idea failed, but many of the fantasies of this\\nbaroque autocrat still managed to become implemented.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"warning\",\n      children: _jsx(_components.p, {\n        children: \"Some parts of this article might be hard to understand without knowledge\\nof Kotlin syntax. I tried to explain every feature I showed, but the\\ngeneral ability to speak Kotlin is strongly suggested.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, let’s begin the journey.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"what-is-s-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#what-is-s-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"What is s DSL\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Domain-specific language (noun): a computer programming language of\\nlimited expressiveness focused on a particular domain\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"—  Martin Fowler Domain-Specific Languages\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here though, I prefer to give DSLs a slightly different definition which\\nreflects what is written in the article\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"a language (or a set of abstractions) that’s built to deal with a\\nspecific domain\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main difference is that a DSL might not only be a separate language\\nbut also a subset of a language which is used to work on a specific\\ndomain. This kind of DSL can even be built in Java with some fluent API,\\nbut very often it’s indistinguishable from a plain good code. To\\ncontrast in Kotlin, many remarkable features might make an internal DSL\\nlook different.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"calling-convention\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#calling-convention\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Calling convention\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first feature actively used by DSLs in Kotlin is a special calling\\nconvention. If the last parameter of a method is a function, and you’re\\npassing a lambda expression there, you can specify it outside of\\nparentheses.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, if one wants to create a function \", _jsx(_components.code, {\n        children: \"dotimes\"\n      }), \" that takes a\\nnumber \", _jsx(_components.code, {\n        children: \"n\"\n      }), \", a function \", _jsx(_components.code, {\n        children: \"f\"\n      }), \" and applies it, the easiest way to do that is\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"good old dotimes\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"dotimes\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(n: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Int\"\n            }), \", f: () -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n        f()\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"dotimes\"\n      }), \" can be called in this way\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"dotimes(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", {\\n    println(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, Kotlin!\\\"\"\n        }), \")\\n})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Or, using the lambda parameter convention and placing lambda function\\noutside parentheses.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"dotimes(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \") {\\n    println(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, Kotlin!\\\"\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Moreover, the parentheses can be omitted completely if a lambda is the\\nonly parameter of a function. E.g. \", _jsx(_components.code, {\n        children: \"do5times\"\n      }), \" function that only takes a\\nlambda as a parameter can be defined and called as\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"do5times\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(f: () -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = dotimes(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", f)\\n\\ndo5times {\\n    println(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, Kotlin!\\\"\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But despite being important, that calling convention is just a tiny\\ncontribution to DSLs when compared to extension functions.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"extension-functions\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#extension-functions\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Extension functions\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extension functions simply allow you to extend the functionality of a\\nclass from the outside.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Simple extension function\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" String.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"removeSpaces\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": String {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \".filter({ c -> c != \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"' '\"\n        }), \" })\\n}\\n\\nprint(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hi ! , ext\\\"\"\n        }), \".removeSpaces()) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Hi!,ext\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, the \", _jsx(_components.code, {\n        children: \"removeSpace\"\n      }), \" function is defined on the class String which\\nenables an ability to call \", _jsx(_components.code, {\n        children: \"removeSpaces\"\n      }), \" on any \", _jsx(_components.code, {\n        children: \"String\"\n      }), \" instance.\\nUnsurprisingly, it removes all the spaces from it. Inside the functions,\\n\", _jsx(_components.code, {\n        children: \"this\"\n      }), \" refers to the instance of a receiver class and can be omitted\\nlike you do when you’re writing a member function. That might sound\\ncomplicated if you have never heard about extension functions before,\\nbut looking at the result of the compilation might make it much easier\\nto understand.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Decompiled java code\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" String \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"removeSpaces\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(String $receiver)\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"StringBuilder\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"sb\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"StringBuilder\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"i\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i < $receiver.length(); i++) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"c\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" $receiver.charAt(i);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (c != \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"' '\"\n        }), \") {\\n      sb.append(c);\\n    }\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" sb.toString();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extension functions are not some kind of magic. It’s not a Groovy-like\\nmonkey patching, they get compiled to simple static functions. But that\\nexample shows us a very important caveat - extension functions are\\nresolved statically because there is no dispatch mechanism for static\\nmethods\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Even though this snippet is very simple, it can raise another question -\\n\\\"where did the \", _jsx(_components.code, {\n        children: \"StringBuilder\"\n      }), \" came from?\\\". An close look at the first\\nsnippet through \", _jsx(_components.code, {\n        children: \"Java\"\n      }), \" glasses gives the answer - there is no function\\ncalled \", _jsx(_components.code, {\n        children: \"filter\"\n      }), \" defined in the class String. \", _jsx(_components.code, {\n        children: \"filter\"\n      }), \" is also an\\nextension function defined in the Kotlin standard library.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"filter function from kotlin stdlib\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"inline\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" String.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"filter\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(predicate: (\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Char\"\n            }), \") -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Boolean\"\n            }), \")\"]\n          })]\n        }), \": String {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" destination = StringBuilder()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (index \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".length - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" element = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"(index)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (predicate(element))\\n      destination.append(element)\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" destination.toString()\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Kotlin defines a lot of extension functions for Java classes in the\\nstandard library. That’s why Kotlin is so convenient to use. One might\\nnotice that the function has an \", _jsx(_components.code, {\n        children: \"inline\"\n      }), \" modifier on it which explains\\nwhy decompiled \", _jsx(_components.code, {\n        children: \"removeSpaces\"\n      }), \" has a \", _jsx(_components.code, {\n        children: \"StringBuilder\"\n      }), \" inside and not a\\ncall to \", _jsx(_components.code, {\n        children: \"filter\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Many newcomers to Kotlin use the \", _jsx(_components.code, {\n        children: \"inline\"\n      }), \" modifier everywhere under the\\nimpression that inlining can improve performance. It can, but in many\\ncases, inline functions don’t improve performance at all, they even can\\nmake it worse. There is an inspection for that in IntelliJ IDEA.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/inspection.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are also some other uses for \", _jsx(_components.code, {\n        children: \"inline\"\n      }), \" which can be found in\\n\", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/inline-functions.html\",\n        children: \"docs\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"extension-function-on-generic-type\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#extension-function-on-generic-type\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Extension function on generic type\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Kotlin compiler is smart enough to allow for the definition of\\nextension functions on a certain generic type. In this example,\\n\", _jsx(_components.code, {\n        children: \"toIntArray\"\n      }), \" function can be called only on a collection that contains\\nintegers. This makes extension functions truly unique, there is no way\\n(without subclassing) to define a method for \", _jsx(_components.code, {\n        children: \"Collection\"\n      }), \" class that can\\nbe called only on an \", _jsx(_components.code, {\n        children: \"Int\"\n      }), \" collection.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" Collection\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<Int>\"\n          }), \".\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"toIntArray\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": IntArray {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result = IntArray(size)\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" index = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (element \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \")\\n    result[index++] = element\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" result\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"listOf(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \").toIntArray()       \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// works\"\n        }), \"\\nlistOf(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"2\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"3\\\"\"\n        }), \").toIntArray() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// type error\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If Kotlin has become your native language, you might be wondering now,\\nwhy I’m talking about these simple features in an article about DSLs.\\nThe thing is, the majority of Kotlin DSLs are based on the\\nexpressiveness of the two features mentioned above.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"first-simple-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#first-simple-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"First simple DSL\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Given the aforementioned features, it’s very easy to write a first very\\nsimple DSL.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s say we need to write an event-based droid fighting platform so\\nthat users can provide their own strategies and register them on the\\nplatform. For each event the user is interested in, they must provide a\\ncallback with the droid’s behaviour. A droid has an interface with a few\\nmethods for defeating other droids. Or, humans if you will.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"the droid\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Droid\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" peopleAround: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Boolean\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" gun: Gun\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"fire\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(gun: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Gun\"\n            }), \")\"]\n          })]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"moveLeft\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"moveRight\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This sounds like an ideal case for DSL and now we need to define a\\npublic API which the clients will be happy to use. To provide the\\ndroid’s behaviour we’ll write a public function.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"API\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" droid: Droid = getDroid() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// inaccessible from the public API\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"on\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(cmd: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \", f: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Droid\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n  droid.f()\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The type of the argument \", _jsx(_components.code, {\n        children: \"f\"\n      }), \" might look weird, but it’s just the type of\\n0-arity extension function on the type Droid. And finally, the APIs\\nconsumers can register events in the platform.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"strategy example\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"on(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"back\\\"\"\n        }), \") {\\n  moveLeft()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (peopleAround) {\\n    fire(gun)\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, the anonymous extension function is a second parameter and\\ntherefore can be written outside parentheses. \", _jsx(_components.code, {\n        children: \"this\"\n      }), \" in the function has\\na type \", _jsx(_components.code, {\n        children: \"Droid\"\n      }), \" and therefore \", _jsx(_components.code, {\n        children: \"moveLeft()\"\n      }), \" as well as other functions and\\nproperties can be called by themselves without providing an explicit\\nreceiver type..\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The strategy looks very natural, it clearly says that if our droid\\nreceives a \", _jsx(_components.code, {\n        children: \"back\"\n      }), \" command, it should move left and try to shoot some\\nfolks around him. The next snippet shows to what it can be compiled to\\nin order to make it even clearer for those who don’t speak kotlin well\\nyet.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"decompiled java call\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [\"on(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"back\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Function1\"\n        }), \"<Droid, Unit>() {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" Unit \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Droid droid)\"\n        }), \" {\\n    droid.moveLeft();\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (droid.getPeopleAround()) {\\n      droid.fire(droid.getGun());\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Unit.INSTANCE;\\n  }\\n});\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"html-builders\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#html-builders\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"HTML builders\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Building DSLs using extension functions isn’t limited to simple droid\\nfighting strategies. For example, it allows us to build a completely\\ntyped HTML syntax; HTML builders are even mentioned in the \", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/type-safe-builders.html\",\n        children: \"official\\ndocumentation\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"html builders\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" list = listOf(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Kotlin\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"is\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"awesome\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result: HTML =\\n  html {\\n    head {\\n      title { +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HTML DSL in Kotlin\\\"\"\n        }), \" }\\n    }\\n    body {\\n      p {\\n        +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a line about Kotlin\\\"\"\n        }), \"\\n      }\\n      a(href = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"jetbrains.com/kotlin\\\"\"\n        }), \") {\\n        +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Kotlin\\\"\"\n        }), \"\\n      }\\n      p {\\n        +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Kotlin is:\\\"\"\n        }), \"\\n        ul {\\n          \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (arg \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" list)\\n            li { +arg }\\n        }\\n      }\\n    }\\n  }\\nprintln(result)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And these type-safe builders aren’t a Kotlin invention, on the JVM land\\nthey were originated in Groovy. But Groovy is a dynamic language,\\nbuilders there are not type-safe.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"important\",\n      children: _jsx(_components.p, {\n        children: \"It wouldn’t be completely fair to say that even though it’s what\\nKotlin’s documentation says, Groovy supports static compilation\\noptionally and there are some ways to compile builders statically as\\nwell.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The implementation of a DSL in dynamically typed languages is often very\\ndifferent to statically typed languages. In Kotlin, in order to build a\\nDSL, you need to describe the whole schema of the future language. And\\ngiven that the result is a deeply nested data structure, the easiest way\\nto convert it to string is to traverse the whole data-structure\\nrecursively.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"base interface\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Element\"\n        }), \" {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"render\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(builder: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"StringBuilder\"\n            }), \", indent: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The simplest line of text can be represented as\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextElement\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" text: String) : Element {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"render\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(builder: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"StringBuilder\"\n            }), \", indent: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \" {\\n    builder.append(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$indent\"\n          }), _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$text\"\n          }), \"\\\\n\\\"\"]\n        }), \")\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The real tag representation is a bit more complex\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"abstract\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" name: String) : Element {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" children = arrayListOf<Element>()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" attributes = hashMapOf<String, String>()\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// open tag\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// render attributes\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// render children recursively\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// close tag\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"render\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(builder: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"StringBuilder\"\n            }), \", indent: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \" {\\n    builder.append(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$indent\"\n          }), \"<\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$name\"\n          }), _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${renderAttributes()}\"\n          }), \">\\\\n\\\"\"]\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (c \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" children) {\\n      c.render(builder, indent + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"  \\\"\"\n        }), \")\\n    }\\n    builder.append(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$indent\"\n          }), \"</\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$name\"\n          }), \">\\\\n\\\"\"]\n        }), \")\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"renderAttributes\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \" = attributes.map { (k, v) -> \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$k\"\n          }), \"=\\\\\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$v\"\n          }), \"\\\\\\\"\\\"\"]\n        }), \" }.joinToString(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \")\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"protected\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<T : Element>\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"initTag\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(tag: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n    tag.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \"()\\n    children.add(tag)\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" String.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"unaryPlus\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \" {\\n    children.add(TextElement(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \"))\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"toString\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": String {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" builder = StringBuilder()\\n    render(builder, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" builder.toString()\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It contains a representation of attributes and a set of children. But\\nthe main part that requires attention is the \", _jsx(_components.code, {\n        children: \"initTag\"\n      }), \" function which\\nlooks very similar to the function \", _jsx(_components.code, {\n        children: \"on\"\n      }), \" from the \\\"robot fighting\\\" DSL\\ndefinition.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Another interesting part is an extension function \", _jsx(_components.code, {\n        children: \"unaryPlus\"\n      }), \" defined as\\nan operator for class String inside the \", _jsx(_components.code, {\n        children: \"Tag\"\n      }), \". It allows us to use a\\nconvenient (but let’s be honest not obvious at all) way to insert a line\\nof text inside code like:\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"¯\\\\_(ツ)_/¯ unary plus to append a line of text\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"body {\\n  +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"just a random line\\\"\"\n        }), \"\\n  +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"another line\\\"\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And the rest of the DSL is an enumeration of all possible tags.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"<head>,<title>,<body>,<a>,<ul>,<li>,<p>\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HTML\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"html\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"head\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Head\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Head(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"body\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Body\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Body(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Head\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"head\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"title\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Title\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Title(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Title\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"title\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"abstract\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BodyTag\"\n        }), \"(name: String) : Tag(name) {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"p\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"P\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(P(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"ul\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"UL\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(UL(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"a\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(href: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"A\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" a = A()\\n    initTag(a, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n    a.href = href\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Body\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"body\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"UL\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ul\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"li\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"LI\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(LI(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LI\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"li\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"P\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"p\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"A\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a\\\"\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" href: String\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"() = attributes[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"href\\\"\"\n        }), \"] ?: \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(value) {\\n      attributes[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"href\\\"\"\n        }), \"] = value\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As you can see, all these classes define a possible hierarchy of calls.\\nThis DSL is just a toy DSL, and therefore it covers a very small and\\nlimited subset of HTML. It is extremely tedious to write the whole HTML\\nDSL manually. The actual \", _jsx(_components.a, {\n        href: \"https://github.com/Kotlin/kotlinx.html\",\n        children: \"HTML DSL\\nimplementation\"\n      }), \" uses a real \", _jsx(_components.a, {\n        href: \"https://github.com/Kotlin/kotlinx.html/blob/master/generate/src/main/resources/html_5.xsd\",\n        children: \"XSD\\nschema\"\n      }), \"\\nto generate all possible classes for the DSL.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"there-is-always-a-problem\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#there-is-always-a-problem\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"There is always a problem\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This could already be awesome, but the example demonstrates a very weird\\nbehaviour — nobody stops you from defining tags inside each other\\nmultiple times.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"the problem\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"head {\\n  head {\\n    head {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// stil possible to write head because implicit receiver html is available\"\n        }), \"\\n    }\\n  }\\n  title { +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"XML encoding with Kotlin\\\"\"\n        }), \" }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Prior to Kotlin 1.1, the only solution was to redefine function with\\ndeprecation.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Head\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"head\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"@Deprecated(message = \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"wrong scope\\\"\"\n          }), \", level = DeprecationLevel.ERROR)\"]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"head\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Head\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Head(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"title\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Title\"\n            }), \".() -> \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Title(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/err1.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The problem with this approach is that it requires an incredible amount\\nof boilerplate and a full understanding of all possible combinations. In\\n1.1,\\n\", _jsx(_components.a, {\n        href: \"https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md\",\n        children: \"KEEP-57\"\n      }), \"\\nintroduced an alternative to that approach: the \", _jsx(_components.code, {\n        children: \"@DslMarker\"\n      }), \" annotation\\nwas introduced which allows us to define a \", _jsx(_components.code, {\n        children: \"DSL marker\"\n      }), \" and introduces a\\nset of rules for classes annotated with that marker:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"an implicit receiver may belong to a DSL if marked with a\\ncorresponding DSL marker annotation\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"two implicit receivers of the same DSL are not accessible in the same\\nscope\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"the closest one wins\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"other available receivers are resolved as usual, but if the resulting\\nresolved call binds to such a receiver, it’s a compilation error\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, the HTML DSL can be fixed by introducing a \", _jsx(_components.code, {\n        children: \"@HtmlTagMarker\"\n      }), \" DSL\\nmarker and annotating \", _jsx(_components.code, {\n        children: \"Tag\"\n      }), \" with it.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@HtmlTagMarker\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"abstract\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" name: String) : Element {\\n \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/err2.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DSLs that give us an ability to construct nested data structures such as\\nHTML builders, different configurations, UI builders, etc. is where\\nKotlin really shines. Kotlin took an awesome idea from Groovy and made\\nit safe and easy to use.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are a few more examples of DSLs of that kind:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://blog.jetbrains.com/teamcity/2016/11/kotlin-configuration-scripts-an-introduction/\",\n            children: \"TeamCity\\nDSL\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://github.com/gradle/gradle-script-kotlin\",\n            children: \"Gradle with Kotlin\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://github.com/gradle/gradle-script-kotlin\",\n            children: \"Anko\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://spekframework.org\",\n            children: \"Spek framework\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But unsurprisingly, it’s not the only type of DSL that can be\\nimplemented in Kotlin…\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"fantastic-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#fantastic-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Fantastic DSL\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Not all domains are born the same. Let’s consider a completely different\\ndomain. A system which handles transactions containing a payment in some\\ncurrency and two people - a sender and a receiver.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain.svg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The transaction structure has to be immutable to make it safer. But\\nsometimes, we might need to create a new transaction with an updated\\nfield. For example, the name of the receiver (from) person might need to\\nbe changed to let’s say \\\"John\\\". There are a few ways to implement that\\nin Kotlin\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"data-classes\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#data-classes\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Data classes\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s start with an idiomatic Kotlin way. The class hierarchy can be\\nconcisely represented as\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"data\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Transaction\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" payment: Payment, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" parts: Parts)\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Payment\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currency: String, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" amount: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Parts\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" from: Person, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" to: Person)\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" id: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" name: String)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An instance of the \", _jsx(_components.code, {\n        children: \"Transaction\"\n      }), \" can easily be created as well\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"create\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trs = Transaction(\\n  Payment(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"),\\n  Parts(\\n    Person(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \"),\\n    Person(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \")\\n  )\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But problems start when we need to update this nested data structure.\\nGenerally, there two ways to do that. The first option is to completely\\nrecreate the transaction which doesn’t look good.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update [1]\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans = Transaction(trs.payment, Parts(\\n  Person(trs.parts.from.id, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"),\\n  trs.parts.to)\\n)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Another is to use\\n\", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/data-classes.html#copying\",\n        children: \"copy\"\n      })]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update [2]\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stansTrs2 = trs.copy(\\n  parts = trs.parts.copy(\\n    from = trs.parts.from.copy(\\n      name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"\\n    )\\n  )\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And the copy version doesn’t look good either. Even though it’s\\ntolerable now, the bigger the data structure, the uglier the code look\\nlike. On a deeply nested immutable data structure, it looks like a\\ntriangle instead of a simple call chain from the mutable world.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"ohhhh\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stansTrs2 = trs.copy(\\n  parts = trs.parts.copy(\\n    from = trs.parts.from.copy(\\n      person = trs.parts.from.person.copy(\\n        parts = trs.parts.from.person.parts.copy(\\n          from = trs.parts.from.person.parts.from.copy(\\n            person = trs.parts.from.person.parts.from.person.copy(\\n              parts = trs.parts.from.person.parts.from.person.parts.copy(\\n                from = trs.parts.from.person.parts.from.person.parts.from.copy(\\n                  person = trs.parts.from.person.parts.from.person.parts.from.person.copy(\\n                    parts = trs.parts.from.person.parts.from.person.parts.from.person.parts.copy(\\n                      from = trs.parts.from.person.parts.from.person.parts.from.person.parts.from.copy(\\n                        name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"jonh\\\"\"\n        }), \"\\n                      ))))))))))))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Don’t get me wrong, I like parentheses. It feels like a lisp (which I\\nlike a lot), but what no one likes is the wall of boilerplate above.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"persistent-data-structures\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#persistent-data-structures\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Persistent Data Structures\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But talking about lisps, there is another awesome language called\\nClojure. It’s a lisp running on JVM where every data structure is\\npersistent (don’t confuse with\\n\", _jsx(_components.a, {\n        href: \"https://stackoverflow.com/questions/10034537/persistent-vs-immutable-data-structure\",\n        children: \"immutable\"\n      }), \").\\nIn Clojure, the same problem can be solved by defining the transaction\\nstructure as a persistent map.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"create\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-clojure\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title\",\n          children: \"ts\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":payment\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":currency\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \"\\n                   \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":amount\"\n        }), \"   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"}\\n         \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":parts\"\n        }), \"   {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":from\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":id\"\n        }), \"   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n                          \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":name\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \"}\\n                   \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":to\"\n        }), \"   {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":id\"\n        }), \"   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n                          \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":name\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \"}}})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Not as concise as Kotlin’s version, but still pretty good. What is\\ncompletely different to Kotlin, is the update function\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-clojure\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title\",\n          children: \"ts2\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-name\",\n          children: \"assoc-in\"\n        }), \" ts [\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":parts\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":name\"\n        }), \"] \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s only one line! And it’s exactly what we aimed for. The next picture\\nmight be essential for understanding how it works.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain_clj.svg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Given that each node has a known type - \", _jsx(_components.code, {\n        children: \"clojure.lang.APersistentMap\"\n      }), \" -\\nand the universal way of traversing is \", _jsx(_components.code, {\n        children: \"map.get(\\\"key\\\")\"\n      }), \", it’s possible\\nto write a function \", _jsx(_components.code, {\n        children: \"assoc-in\"\n      }), \" which can change a value under a given\\n\\\"path\\\" and to recreate the data structure \", _jsx(_components.a, {\n        href: \"http://cjohansen.no/clojure-to-die-for/\",\n        children: \"node by\\nnode\"\n      }), \". But Clojure’s internals\\nare plain java classes that can be used from Kotlin easily just with a\\nfew \\\"convenience\\\" adapters to keep familiar syntax.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"create\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" tran = pArrayMap(\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"payment\\\"\"\n        }), \" to pArrayMap(\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"currency\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"amount\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"\\n  ),\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parts\\\"\"\n        }), \" to pArrayMap(\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"from\\\"\"\n        }), \" to pArrayMap(\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \"\\n    ),\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"to\\\"\"\n        }), \" to pArrayMap(\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \"\\n    )\\n  )\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Yes, the creation looks rather ugly. It’s untyped, all the key names are\\nrepresented as strings, but let’s look at the update function.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans2 = trans.pUpdate(listOf(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parts\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"from\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s still as concise and beautiful as Clojure’s one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But is it possible to build a DSL which keeps types from Kotlin types\\nand provides the conciseness of Clojure?\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"cursor-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#cursor-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Cursor DSL\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is possible! Using a special DSL, you can define the structure of the\\n\\\"transactional\\\" domain in a following way.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Transaction\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Transaction, F>.payment \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node<Payment>()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Transaction, F>.parts \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node<Parts>()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Payment\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Payment, F>.currency \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf<String>()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Payment, F>.amount \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf<\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \">()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Parts\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Parts, F>.to \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node<Person>()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Parts, F>.from \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node<Person>()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Person, F>.id \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf<\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \">()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Person, F>.name \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf<String>()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This looks scary, but it’s just a bit of necessary boilerplate. This\\ncode should be read like\"\n    }), \"\\n\", _jsxs(\"pre\", {\n      style: {\n        margin: 0,\n        background: \"white\",\n        lineHeight: \"125%\"\n      },\n      children: [_jsxs(_components.p, {\n        children: [_jsx(\"style\", {\n          children: `\n.prh-keyword {\n  color: #000080;\n  font-weight: bold;\n}\n.prh-boilerplate {\n  opacity: 0.2;\n}\n`\n        }), \"\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"interface\"\n        }), \" Transaction\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Transaction\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".payment \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Node<\"\n        }), \"Payment\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        }), \"\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Transaction\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".parts \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Node<\"\n        }), \"Parts\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        })]\n      }), _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"interface\"\n        }), \" Payment\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Payment\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".currency \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Leaf<\"\n        }), \"String\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        }), \"\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Payment\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".amount \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Leaf<\"\n        }), \"Int\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        })]\n      }), _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"interface\"\n        }), \" Parts\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Parts\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".to \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Node<\"\n        }), \"Person\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        }), \"\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Parts\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".from \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Node<\"\n        }), \"Person\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        })]\n      }), _jsxs(_components.p, {\n        children: [_jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"interface\"\n        }), \" Person\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Person\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".id \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Leaf<\"\n        }), \"Int\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        }), \"\\n\", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"val\"\n        }), _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \" <F> Cursor<\"\n        }), \"Person\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \", F>\"\n        }), \".name \", _jsx(\"span\", {\n          class: \"prh-keyword\",\n          children: \"by\"\n        }), \" \", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \"Leaf<\"\n        }), \"String\", _jsx(\"span\", {\n          class: \"prh-boilerplate\",\n          children: \">()\"\n        })]\n      })]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The creation looks very similar to the untyped version, but it’s\\ncompletely typed. It references properties defined above.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans = domain<Transaction> {\\n  (payment) {\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \")\\n  }\\n  (parts) {\\n    (from) {\\n      id.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n      name.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \")\\n    }\\n    (to) {\\n      id.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n      name.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \")\\n    }\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s possible to update the transaction easily. And not just one field,\\nin fact, the code above creates an empty data structure and applies an\\nupdate function to it.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans2 = trans.cursor.parts.from.update {\\n  name.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \")\\n}\\nprintln(trans.cursor.parts.from.name.value) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Alex\\\"\"\n        }), \"\\nprintln(trans2.cursor.parts.from.name.value) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"John\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"or\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans3 = trans2.cursor.update {\\n  (payment) {\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"USD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"What is really awesome is that the \", _jsx(_components.code, {\n        children: \"set\"\n      }), \" function can only be called\\ninside the \", _jsx(_components.code, {\n        children: \"update\"\n      }), \" block. It’s possible to think about the \", _jsx(_components.code, {\n        children: \"update\"\n      }), \"\\nblock as an open transaction where a few updates are applied.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#implementation\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"read\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#read\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Read\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The easiest way to start implementing it is to imagine that the data\\nstructure is already created and everything we need to do is to read a\\nvalue from it. The obvious untyped solution will be to call\\n\", _jsx(_components.code, {\n        children: \"trans.get(\\\"parts\\\").get(\\\"from\\\").get(\\\"name\\\")\"\n      }), \". And this approach works\\nfine until we need to update it. After the first \", _jsx(_components.code, {\n        children: \"get\"\n      }), \" call, the\\nreference to the root transaction is lost and there’ll be no way to run\\nthe update operation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead, it’s possible to focus on the way of traversing the data\\nstructure without loosing the reference to the root. To accomplish this,\\nit’s possible to implement \", _jsx(_components.code, {\n        children: \"Focus\"\n      }), \" interface which holds the reference\\nto the root and accumulates a path inside.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Focus\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out Op\"\n        }), \"> {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"narrow\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Focus<Op>\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" op: Op\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The interesting thing that \", _jsx(_components.code, {\n        children: \"Focus\"\n      }), \" is parametrised over an operation.\\nThat operation can be \", _jsx(_components.code, {\n        children: \"Read\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"Write\"\n      }), \" depending on the context. When a\\nleaf is reached, the typed version will finally perform an action using\\nthat operation.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"narrow down the usage\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f = Focus(trans)       \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// {\\\"root\\\" -> Transaction, path -> []}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f2 = f.narrow(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parts\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// {\\\"root\\\" -> Transaction, path -> [\\\"parts\\\"]}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f3 = f2.narrow(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"from\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// {\\\"root\\\" -> Transaction, path -> [\\\"parts\\\", \\\"from\\\"]}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain_focus.svg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But even though the focus does its job very well, it’s completely\\nuntyped, and strings have to be used to navigate through. The type must\\nbe stored somewhere. As everyone knows that any problem can be solved\\nwith an additional layer of abstraction! Let’s define a wrapper\\nparametrised over the type of an underlying node.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"the missed layer\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cursor\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T, out Op\"\n        }), \">(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f: Focus<Op>)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Cursor\"\n      }), \" is parametrised over a node type and the \", _jsx(_components.code, {\n        children: \"operation\"\n      }), \" is derived\\nfrom the focus. And now, the \", _jsx(_components.code, {\n        children: \"Transaction\"\n      }), \" definition starts making\\nsense. The narrowing can be delegated to the \", _jsx(_components.code, {\n        children: \"Node\"\n      }), \" object that knows\\nthe type and uses the name of a property to create a new \", _jsx(_components.code, {\n        children: \"Cursor\"\n      }), \" with a\\nnew \", _jsx(_components.code, {\n        children: \"Focus\"\n      }), \" inside.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Transaction\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Transaction, F>.payment \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node<Payment>()\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, the \", _jsx(_components.code, {\n        children: \"payment\"\n      }), \" is an extension property on the \", _jsx(_components.code, {\n        children: \"Transaction\"\n      }), \" type\\nwhich is just a marker interface. It will never be instantiated, instead\\nby delegating property to \", _jsx(_components.code, {\n        children: \"Node<Payment>\"\n      }), \", the conversion\\n\", _jsx(_components.code, {\n        children: \"Cursor<Transacton, F> => Cursor<Payment, F>\"\n      }), \" will be made.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"how Node is defined\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Node\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T\"\n        }), \"> {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<Op>\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getValue\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(ref: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"<*, Op>, property: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"KProperty\"\n            }), \"<*>)\"]\n          })]\n        }), \": Cursor<T, Op> {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Cursor(ref.f.narrow(property.name))\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Inside \", _jsx(_components.code, {\n        children: \"Node\"\n      }), \", a new Cursor is created with the focus narrowing down\\nusing a property name. Using this technique, by just calling extension\\nproperties a focus can narrow down to the last node where the last node\\nis delegated to \", _jsx(_components.code, {\n        children: \"Leaf\"\n      }), \" instead of \", _jsx(_components.code, {\n        children: \"Node\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <F> Cursor<Person, F>.name \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf<String>()\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Leaf<V>\"\n      }), \" is defined in the same way as Node except for the return value\\nof \", _jsx(_components.code, {\n        children: \"getValue\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Leaf\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out V\"\n        }), \"> {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<Op>\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getValue\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(ref: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"<*, Op>, property: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"KProperty\"\n            }), \"<*>)\"]\n          })]\n        }), \": Cursor<Leaf<V>, Op> {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Cursor(ref.f.narrow(property.name))\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Leaf is needed to define an extension property that allows reading a\\nvalue from that node. The property has the following signature\\n\", _jsx(_components.code, {\n        children: \"val <V, T> Cursor<Leaf<V>, Read<T>>.value: V\"\n      }), \" which says: given the\\ncursor focused on a leaf and parametrised over a read operation, provide\\na value contained by the leaf.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain_red.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The remaining logic is described below\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// the main data structure where T type - is the root type\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// in our case, T is Transaction.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// root is just an empty persisntent map\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Domain\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T\"\n        }), \">(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" root: PMap = PHashMap.EMPTY)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// The read operation that focus owns (Op)\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Read\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out M\"\n        }), \"> {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" path: Path         \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// path to the current node (ex. [\\\"payment\\\", \\\"currency\\\"])\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" domain: Domain<M>  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// the reference to the root\"\n        }), \"\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// the implementation of the focus\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Reader\"\n        }), \"<\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T\"\n        }), \">(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" p: Path, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" dm: Domain<T>) : Focus<Read<T>> {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// this is how narrowing happens, just extend the path and keep the refernce to the root\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"narrow\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Focus<Read<T>> = Reader(p.append(k), dm)\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" op: Read<T> = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"object\"\n        }), \" : Read<T> {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" domain: Domain<T> = dm\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" path: Path = p\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// take a focus, take a read operation from it and ask for value\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// by traversing the root using path\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <V, T> Cursor<Leaf<V>, Read<T>>.value: V\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"() = f.op.path.getIn(f.op.domain.root) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" V\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// this is how cursor get's created, emtpy path and reference to the root\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" <T> Domain<T>.cursor: Cursor<T, Read<T>>\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"() = Cursor(Reader(Path.EMPTY, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"update\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#update\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Update\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So far we can traverse the data structure and read values from it. The\\nnext step is to learn how to update it. Problems start when we realise\\nthat the underlying data structure is persistent and there is no way to\\nmutate it. To emulate mutation, a special wrapper has to be defined. It\\nreassigns the reference after each mutation.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"immutable ⇒ mutable\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Mutable\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" m: PMap) {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"write\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(p: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Path\"\n            }), \", a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \" {\\n    m = p.assocIn(m, a)\\n  }\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"read\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(p: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Path\"\n            }), \")\"]\n          })]\n        }), \" = p.getIn(m)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, we’ll need to implement the \", _jsx(_components.code, {\n        children: \"Write\"\n      }), \" operation which supports\\nreading and writing under a specific path. At first glance, \", _jsx(_components.code, {\n        children: \"read\"\n      }), \"\\noperation is unnecessary, but it’s needed to read the final result after\\nall modification were applied using an empty path. Another application\\nof the \", _jsx(_components.code, {\n        children: \"read()\"\n      }), \" operation is node initialisation. E.g. if you create an\\nempty domain and decide to write a value to leaf using a cursor, all the\\nparent nodes need to be initialised first.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsxs(_components.strong, {\n          children: [\"Op for \", _jsx(_components.code, {\n            children: \"Cursor<T, Write>\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Write\"\n        }), \" {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"read\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": Any?\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"write\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And the corresponding cursor\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WriterCursor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" m: Mutable, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" path: Path) : Focus<Write> {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// exactly the same narrowing pattern\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"narrow\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Focus<Write> = WriterCursor(m, path.append(k))\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" op: Write = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"object\"\n        }), \" : Write {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"write\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \" = m.write(path, a)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"read\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": Any? = m.read(path)\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"And at some point in time, we might want to switch from the \", _jsx(_components.code, {\n        children: \"Read\"\n      }), \"\\ncursor to the \", _jsx(_components.code, {\n        children: \"Write\"\n      }), \" cursor. For that, a special function exists.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Cursor<T, Read> ⇒ Cursor<T, Write>\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<T, M>\"\n          }), \" Cursor\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<M, Read<T>\"\n          }), \">.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"update\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(update: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"<\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"M\"\n            }), \", Write>.()\"]\n          })]\n        }), \" -> \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \"): Domain<T> {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// take a root, make a mutable from it\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" m = Mutable(f.op.domain.root)\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// create a writer from mutable and apply `update` supplied from outside\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// exactly the same pattern as any other DSL has\"\n        }), \"\\n  Cursor<M, Write>(WriterCursor(m, f.op.path)).update()\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// read the final value from the root and return a new instance of Domain\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Domain(m.read(Path.EMPTY) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" PMap)\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// to simplify the initialisation\"\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<M>\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"domain\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(f: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"<\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"M\"\n            }), \", Write>.()\"]\n          })]\n        }), \" -> \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \") = Domain<M>().cursor.update(f)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And finally, a set of public typed operation that API consumers use\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// for each leaf initial value is null\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// for each node initial value is empty persistent map\"\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" Write.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"init\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"KClass\"\n            }), \"<*>)\"]\n          })]\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (read() == \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \") {\\n    write(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"when\"\n        }), \" (k) {\\n      Leaf::\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" -> \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" -> PArrayMap.EMPTY\\n    })\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"inline\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsxs(_components.span, {\n            className: \"hljs-type\",\n            children: [\"<\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"reified\"\n            }), \" T>\"]\n          }), \" Cursor\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<T, Write>\"\n          }), \".\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"invoke\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\\n    updateFn: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"<\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \", Write>.()\"]\n          })]\n        }), \" -> \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// init the current node (it might be null if we haven't visited it before)\"\n        }), \"\\n  f.op.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \"(T::\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \")\\n  updateFn()\\n}\\n\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<T>\"\n          }), \" Cursor\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"<Leaf<T>\"\n          }), \", Write>.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"set\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(t: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \")\"]\n          })]\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// just delegate to write\"\n        }), \"\\n  f.op.write(t)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"invoke\"\n      }), \" function is responsible for Node initialisation whereas\\n\", _jsx(_components.code, {\n        children: \"set\"\n      }), \" sets the Leaf’s value\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"domain<Transaction> {\\n  (payment) {  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// <- here invoke is called\"\n        }), \"\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \")\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ↑ is equal to the desugarised version ↓\"\n        }), \"\\ndomain<Transaction> {\\n  payment.invoke({\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \")\\n  })\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And at the end, a Path that does all the work, but in fact, it does\\nnothing except for delegating functionality to functions from Clojure\\nthat do all the work on untyped persistent data structures.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" clojure.`core$assoc_in` \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" assocIn\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" clojure.`core$get_in` \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" getIn\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" clojure.lang.*\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Path\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" v: APersistentVector) {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"companion\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"object\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" EMPTY = Path(PersistentVector.EMPTY)\\n  }\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"append\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Path = Path(v.cons(a) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" APersistentVector)\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getIn\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(model: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \": Any? = getIn.invokeStatic(model, v)\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"assocIn\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(m: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?, a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \": Any? = assocIn.invokeStatic(m, v, a)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Using these primitives, we built a really powerful type safe DSL to work\\non immutable data structures. Yes, it has a few downsides. E.g. data\\nclasses solution has better performance. And most of the time it’s\\nconcise enough, unless you have a really deeply nested tree. In that\\ncase, you might also try to use \", _jsx(_components.a, {\n        href: \"https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing\",\n        children: \"the lenses\\npattern\"\n      }), \"\\nwhich comes from the functional world and solves the same problem. But\\nif you already have untyped data structures in your project and have to\\nwork with them, Kotlin provides a truly unique set of features that\\nallows you to build a powerful DSL to make your life safer and easier.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It’s very probable that some parts of the solution shown above might\\nstill be unclear, in that case, I encourage you to clone \", _jsx(_components.a, {\n        href: \"https://github.com/SerCeMan/talk-fantastic-dsls-example\",\n        children: \"the code\\nexample\"\n      }), \" in\\nyour IDE, run it and try to play with types. It will help a lot and can\\ngive you some interesting ideas on how advanced Kotlin features can be\\nused.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"conclusions\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#conclusions\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Conclusions\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Kotlin provides many unique features to build DSLs easily\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"DSLs in Kotlin work best as configuration APIs\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"They can be a powerful abstraction over untyped data structures\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"warnings\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#warnings\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Warnings\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Most of the time plain code is better than DSL\\nThere is no point in building DSL \\\"just because I can\\\", plain Kotlin\\ncode is often much easier to read and understand.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Provide a way to extend and bypass your DSL\\nIf you publish DSL as a part of your API, it’s always a good idea to\\ngive a way to bypass or extend it. Of course, if it’s a Gradle-like\\nDSL then you can cover everything. But in the case of a html DSL, a\\nuser might want to introduce some tags that your DSL doesn’t support.\\nOr, he can have an already rendered string which needs to be inserted\\nsomewhere.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"links\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#links\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Links\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://github.com/SerCeMan/talk-fantastic-dsls-example\",\n            children: \"Cursor DSL source\\ncode\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Why you should use DSLs: \", _jsx(_components.a, {\n            href: \"http://jonnyzzz.com/blog/2016/09/02/dsl-building/\",\n            children: \"Building DSL Instead of an IDE\\nPlugin\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Why you shouldn’t: \", _jsx(_components.a, {\n            href: \"https://victor.kropp.name/blog/kotlin-dsls-good-bad-and-ugly/\",\n            children: \"DSLs in Kotlin: The Good, the Bad and the\\nUgly\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"thanks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#thanks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Thanks\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Kotlin team for creating an awesome language!\\nPlease, press a ★ button on the \", _jsx(_components.a, {\n            href: \"https://github.com/JetBrains/kotlin\",\n            children: \"Kotlin’s GitHub\\nrepo\"\n          }), \" if you haven’t done it yet.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://twitter.com/jetzajac\",\n            children: \"@JetZajac\"\n          }), \" who initially came up with\\nthe idea of persistent data structure based DSLs\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You for reading it\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"share-this-article\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#share-this-article\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Share this article\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://twitter.com/SerCeMan/status/880365305314254848\",\n          children: \"Twitter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://news.ycombinator.com/item?id=14663115\",\n          children: \"Hacker News\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Fantastic DSLs and where to find them","description":"Empty","date":"2017-06-29"}},"frontMatter":{"title":"Fantastic DSLs and where to find them","description":"Empty","date":"2017-06-29"}},"__N_SSG":true}