<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>You don&#x27;t need no Service Mesh - Hunter Chang</title><meta content="Empty" name="description"/><meta property="og:url" content="https://nextjs-typescript-mdx-blog.vercel.app/posts/23-07-2020-you-dont-need-no-service-mesh"/><link rel="canonical" href="https://nextjs-typescript-mdx-blog.vercel.app/posts/23-07-2020-you-dont-need-no-service-mesh"/><meta property="og:type" content="article"/><meta property="og:site_name" content="You don&#x27;t need no Service Mesh - Hunter Chang"/><meta property="og:description" content="Empty"/><meta property="og:title" content="You don&#x27;t need no Service Mesh - Hunter Chang"/><meta property="og:image" content="https://serce.meundefined"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@huntarosan"/><meta name="twitter:title" content="You don&#x27;t need no Service Mesh - Hunter Chang"/><meta name="twitter:description" content="Empty"/><meta name="twitter:image" content="https://serce.meundefined"/><meta property="article:published_time" content="2020-07-23"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/85ebde2875f9a2f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/85ebde2875f9a2f0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6356dc4d41292890.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6356dc4d41292890.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-6108e5f9f07f1e88.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-cc30d3db21e1456f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d4bf991221a140f0.js" defer=""></script><script src="/_next/static/chunks/660-110f10b88868d913.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3206bcd67143127b.js" defer=""></script><script src="/_next/static/DXtfXN-a50Sw3EddhgVEM/_buildManifest.js" defer=""></script><script src="/_next/static/DXtfXN-a50Sw3EddhgVEM/_ssgManifest.js" defer=""></script></head><body style="background-color:#f2f2f2" class="bg-white text-gray-900 dark:text-white"><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if(e){c.add(e|| '')}else{c.add('light');}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'light'}catch(t){}}();</script><header style="background-color:#f8f8f8" class="relative shadow-md"><div class="max-w-5xl px-8 py-1 mx-auto"><div class="flex items-center justify-between"><nav class="flex justify-between items-center w-full text-lg"><a style="font-family:Alegreya" class="text-gray-500 pr-6 py-4 float-left w-1/2 text-4xl" href="/">SerCe&#x27;s blog</a><div class="float-right"><a class="text-gray-600 px-6 py-4" href="/">Home</a><a class="text-gray-600 px-6 py-4" href="/blog">Blog</a></div></nav></div></div></header><main><div><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/default.min.css"/><article class="container mx-auto mt-12 px-10 py-8 shadow-md bg-white max-w-5xl flex flex-col"><p class="self-start text-sm text-gray-500">23 July 2020</p><div class="asciiprose"><h1 class="text-gray-900">You don&#x27;t need no Service Mesh</h1><p>Hi!</p>
<p>Service meshes have attracted an enormous amount of hype around them.
With at least a few talks about service meshes during each tech
conference, one can easily be convinced that having a service mesh in
their infrastructure is a must. However, hype isn’t a good indicator of
whether the new shiny tech is the right solution for your problems. So
below, I’ll try to express an anti-hype opinion on service meshes to
hopefully make it less confusing when you want to decide whether you may
or may not need one.</p>
<p><img src="/images/servicemesh/rick.png" alt=""/></p>
<div class="quoteblock"><blockquote><div class="paragraph"><p>There’s a lesson here, and I’m not going to be the one to figure it out.</p></div></blockquote><div class="attribution">— <!-- -->Rick Sanchez</div></div>
<h2 id="the-invention"><a class="anchor" href="#the-invention"><span class="icon icon-link"></span></a>The invention</h2>
<p>Let’s take a step back in history and take a look at one of the <a href="https://eng.lyft.com/envoy-7-months-later-41986c2fd443">early
articles</a> about
introducing Envoy at Lyft.</p>
<blockquote>
<p>As it turns out, almost every company with a moderately-sized service
oriented architecture is having the same problems that Lyft did prior
to the development and deployment of Envoy:</p>
<ul>
<li>
<p>An architecture composed of a variety of languages, each containing
a half-baked RPC library, including partial (or zero)
implementations of rate limiting, circuit breaking, timeouts,
retries, etc.</p>
</li>
<li>
<p>Differing or partial implementations of stats, logging, and ….</p>
</li>
</ul>
</blockquote>
<p>While Envoy is not a service mesh by itself, the outlined problems
describe the exact reason why service meshes were invented. They add
“rate limiting, circuit breaking, …” and other reliability,
observability, and security features to the services by enforcing the
communication to go through the service mesh proxies, a data plane.
Additionally, they require a separate component, a control plane, to
control the configuration.</p>
<p>However, at this point, a lot of people miss the context in which
service meshes were introduced. Service meshes are able to solve the
problem not because it’s impossible to solve them in any other way.
There are many battle-proof RPC libraries that take on the challenges of
a separate data plane layer,
<a href="https://github.com/twitter/finagle">Finagle</a>,
<a href="https://github.com/grpc">gRPC</a>,
<a href="https://github.com/line/armeria">Armeria</a>,
<a href="https://github.com/apple/servicetalk">Servicetalk</a>, to name a few.
After all, the very first service mesh - Linkerd 1.0 <a href="https://github.com/linkerd/linkerd">is powered by
Finagle</a>. The RPC libraries will
need a component which provides service discovery and configuration
management to make it a true mesh. For instance, Zookeeper, or Consul, a
component that service meshes call a control plane.</p>
<p>Why introduce a new concept to solve the problems that have been solved
before? The service mesh concept wasn’t introduced to address problems
that hadn’t been addressed before but rather address them in a way that
doesn’t require any modifications to the application code, which is
incredibly convenient when it’s hard to introduce an RPC layer into an
existing heterogeneous microservice environment.</p>
<p>When you hear service mesh, Istio with Envoy might be the first thing
that comes to mind, but it wasn’t the first service mesh to enter the
market. Linkerd authors who pioneered the space, described exactly this
situation in the <a href="https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary">&quot;why is the service mesh necessary&quot;</a>.
Interestingly, in many hype-y articles on the Internet this context is
often forgotten, or omitted.</p>
<p>Solving a problem well, even if it’s a problem that a lot of people
have, doesn’t magically provide the tech with a lot of hype. There is
always a sponsor behind it. I don’t know who the sponsor was here, and
I’m going to speculate, but it’s hard to sell an RPC library in the
world where open source is a fundamental requirement. There is no clear
business model there, that’s why most of the mature RPC libraries were
open-sourced by large tech companies for which it’s not a part of the
core business model. A library is just code, not a piece of
infrastructure. Service meshes are a different story. It’s an isolated
non-trivial piece of infrastructure. As a vendor, not only can you
provide consultancy around the configuration and deployment, but you can
also sell complete hosted solutions around it.</p>
<h2 id="disillusionments"><a class="anchor" href="#disillusionments"><span class="icon icon-link"></span></a>Disillusionments</h2>
<p>Now that we’ve established the problems, the solution, and most
importantly, the context in which the solution was made, let’s take a
look at the alternatives. The most obvious one, in the spirit of KISS,
is to use an RPC library for your preferred language. Here is where the
context is crucial: if you have a large fleet of services, each written
in its own language/ecosystem, and the only language that they share is
HTTP then having a single shared RPC library is going to be hard.
Perhaps, you’ve got a fabric of deployed and running services, but
everyone is afraid of touching them, no one knows how they work, and
each redeploy is an adventure. A service mesh is here to help you,
because at least you’ll be able to roll out new infrastructure features
to the mesh regularly.</p>
<p>On the other hand, if you have a fleet of healthy services written in a
single application stack, then it’s a good idea to think twice before
introducing a service mesh. By simply introducing or evolving a shared
RPC library, you’ll get the exact same benefits and avoid dealing with
the downsides of maintaining service meshes. By studying the service
mesh limitations thoroughly, you can avoid finding yourself in the
trough of disillusionment.</p>
<p><img src="/images/servicemesh/curve.png" alt="Hype Cycle"/></p>
<h3 id="different-ecosystem"><a class="anchor" href="#different-ecosystem"><span class="icon icon-link"></span></a>Different ecosystem</h3>
<p>The ecosystem of the service mesh of your choice will likely be
different from the ecosystem of your services. Beautiful websites always
make you believe that the solution is plug’n&#x27;play, always works and
never goes down. In reality, sooner or later problems, bugs, quirks in
behaviour will reveal themselves, as they always do. At that point,
you’ll need to have engineers who work on the service-mesh’s ecosystem
which when it’s different from the main app, effectively limits the set
of people who can introduce changes or fix problems. This is likely to
reintroduce silos, which is against the whole DevOps spirit. Yes, having
a DevOps team of engineers who are doing DevOps-y things <a href="https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/">is against
DevOps</a>.</p>
<h3 id="unnecessary-overhead"><a class="anchor" href="#unnecessary-overhead"><span class="icon icon-link"></span></a>Unnecessary overhead</h3>
<p>Not only having a proxy in front of each service adds overhead (often
significant, talking about
<a href="https://istio.io/latest/docs/ops/deployment/performance-and-scalability/">90pt</a>
rather than 99pt in the performance summary <a href="https://www.infoq.com/presentations/latency-response-time/">doesn’t make software run
faster</a>) and
consumes resources, but you also requires time (or rather a team of
people) to manage them. Yes, it can help to make some of the tasks
potentially easier - yay, you can now add canary deployments with a few
lines of YAML to simple applications now. However, you still need to
manage canary deployments of the proxies themselves which don’t have a
proxy in front of them. The problems just get pushed up the stack.</p>
<h3 id="limiting-your-architecture-to-what-the-proxy-supports"><a class="anchor" href="#limiting-your-architecture-to-what-the-proxy-supports"><span class="icon icon-link"></span></a>Limiting your architecture to what The Proxy supports.</h3>
<p>As you’re reading this paragraph, HTTP/3 is slowly being rolled out to
the Internet. It uses UDP as transport. Why use UDP rather than create a
completely new protocol you ask? That’s because anything but TCP and UDP
is simply “blocked” by the boxes, various proxies on the internet -
routers, gateways, etc. This phenomenon got named
<a href="https://http3-explained.haxx.se/en/why-quic/why-ossification">ossification</a>.
So, only TCP or UDP are left is the practical chose, and even UDP is
partially blocked by various corporate proxies which slows down the
adoption.</p>
<p>Even though your microservice environment is probably much smaller
compared to the Internet, you can draw parallels with service meshes.
Proxies can ossify your application architecture by limiting how your
services talk to each other, and there is not much benefit in having
proxies if you can bypass them. Suppose you want to build a reactive
application which is using RSocket over pure tcp? Or perhaps a
message-driven application using an actor model? Or maybe push the
performance boundaries with Aeron? Not going to happen until the box in
the middle becomes aware of the protocol.</p>
<h2 id="do-i-need-one"><a class="anchor" href="#do-i-need-one"><span class="icon icon-link"></span></a>Do I need one?</h2>
<p>What does it all mean for you as an engineer? The answer to whether you
need to adopt the service mesh approach comes down to the state of the
microservice environment you’re trying to improve. As we have
established, compared to an RPC framework, service meshes allow you to:</p>
<ol>
<li>Deploy the infra changes more often than deploying your services.</li>
<li>Introduce infra changes without touching the service code.</li>
</ol>
<p>The point 1. is important when for whatever reason you can’t redeploy
your services very often, e.g. maybe no one remembers how it’s done
anymore, or maybe there are other restrictions. The point 2. is
important when your stack is heterogeneous, e.g. some services are built
in Go, some in Java, some in Haskell, etc. Where are you on the interval
from a huge set of heterogeneous services with unknown deployment
schedules to a set of homogenous regularly deployed services defines
whether a service mesh is the best solution for you.</p>
<h2 id="conclusion"><a class="anchor" href="#conclusion"><span class="icon icon-link"></span></a>Conclusion</h2>
<p>Service meshes have a lot of hype around them, and way too much in my
opinion. However, before committing to a piece of technology, it’s
crucial to understand the problems it solves, and the context in which
the solution was made. A service mesh is not an ultimate “good practice”
but simply one of the patterns to solve a set of issues, and it’s quite
a heavy one.</p>
<p>Rather than jumping on board, look carefully - the last thing you want
is to find out that you have invested in a solution for a problem that
you don’t have. Service meshes are an amazing piece of tech solving a
whole lot of problems. Not in every case, it is the best solution.</p>
<h2 id="thank-you-to"><a class="anchor" href="#thank-you-to"><span class="icon icon-link"></span></a>Thank you to</h2>
<ul>
<li>You for reading this article.</li>
<li><a href="https://twitter.com/ptuls">Paul Tune</a> for reviewing the article.</li>
</ul>
<h2 id="references"><a class="anchor" href="#references"><span class="icon icon-link"></span></a>References</h2>
<ul>
<li><a href="https://eng.lyft.com/envoy-7-months-later-41986c2fd443">https://eng.lyft.com/envoy-7-months-later-41986c2fd443</a></li>
<li><a href="https://github.com/linkerd/linkerd/">https://github.com/linkerd/linkerd/</a></li>
<li><a href="https://servicemesh.io/">https://servicemesh.io/</a></li>
<li><a href="https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/">https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/</a></li>
<li><a href="https://http3-explained.haxx.se/en/why-quic/why-ossification">https://http3-explained.haxx.se/en/why-quic/why-ossification</a></li>
<li><a href="https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary">https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary</a></li>
</ul>
<h2 id="discuss-on"><a class="anchor" href="#discuss-on"><span class="icon icon-link"></span></a>Discuss on</h2>
<ul>
<li><a href="https://twitter.com/SerCeMan/status/1286242507664191488">Twitter</a></li>
<li><a href="https://news.ycombinator.com/item?id=25148642">Hacker News</a></li>
</ul></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    blockquote: \"blockquote\",\n    ul: \"ul\",\n    li: \"li\",\n    h3: \"h3\",\n    ol: \"ol\"\n  }, _provideComponents(), props.components), {Quote} = _components;\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Hi!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Service meshes have attracted an enormous amount of hype around them.\\nWith at least a few talks about service meshes during each tech\\nconference, one can easily be convinced that having a service mesh in\\ntheir infrastructure is a must. However, hype isn’t a good indicator of\\nwhether the new shiny tech is the right solution for your problems. So\\nbelow, I’ll try to express an anti-hype opinion on service meshes to\\nhopefully make it less confusing when you want to decide whether you may\\nor may not need one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/servicemesh/rick.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quote, {\n      quote: \"There’s a lesson here, and I’m not going to be the one to figure it out.\",\n      attribution: \"Rick Sanchez\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"the-invention\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#the-invention\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"The invention\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Let’s take a step back in history and take a look at one of the \", _jsx(_components.a, {\n        href: \"https://eng.lyft.com/envoy-7-months-later-41986c2fd443\",\n        children: \"early\\narticles\"\n      }), \" about\\nintroducing Envoy at Lyft.\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"As it turns out, almost every company with a moderately-sized service\\noriented architecture is having the same problems that Lyft did prior\\nto the development and deployment of Envoy:\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"An architecture composed of a variety of languages, each containing\\na half-baked RPC library, including partial (or zero)\\nimplementations of rate limiting, circuit breaking, timeouts,\\nretries, etc.\"\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsx(_components.p, {\n            children: \"Differing or partial implementations of stats, logging, and ….\"\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"While Envoy is not a service mesh by itself, the outlined problems\\ndescribe the exact reason why service meshes were invented. They add\\n“rate limiting, circuit breaking, …” and other reliability,\\nobservability, and security features to the services by enforcing the\\ncommunication to go through the service mesh proxies, a data plane.\\nAdditionally, they require a separate component, a control plane, to\\ncontrol the configuration.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"However, at this point, a lot of people miss the context in which\\nservice meshes were introduced. Service meshes are able to solve the\\nproblem not because it’s impossible to solve them in any other way.\\nThere are many battle-proof RPC libraries that take on the challenges of\\na separate data plane layer,\\n\", _jsx(_components.a, {\n        href: \"https://github.com/twitter/finagle\",\n        children: \"Finagle\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://github.com/grpc\",\n        children: \"gRPC\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://github.com/line/armeria\",\n        children: \"Armeria\"\n      }), \",\\n\", _jsx(_components.a, {\n        href: \"https://github.com/apple/servicetalk\",\n        children: \"Servicetalk\"\n      }), \", to name a few.\\nAfter all, the very first service mesh - Linkerd 1.0 \", _jsx(_components.a, {\n        href: \"https://github.com/linkerd/linkerd\",\n        children: \"is powered by\\nFinagle\"\n      }), \". The RPC libraries will\\nneed a component which provides service discovery and configuration\\nmanagement to make it a true mesh. For instance, Zookeeper, or Consul, a\\ncomponent that service meshes call a control plane.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Why introduce a new concept to solve the problems that have been solved\\nbefore? The service mesh concept wasn’t introduced to address problems\\nthat hadn’t been addressed before but rather address them in a way that\\ndoesn’t require any modifications to the application code, which is\\nincredibly convenient when it’s hard to introduce an RPC layer into an\\nexisting heterogeneous microservice environment.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"When you hear service mesh, Istio with Envoy might be the first thing\\nthat comes to mind, but it wasn’t the first service mesh to enter the\\nmarket. Linkerd authors who pioneered the space, described exactly this\\nsituation in the \", _jsx(_components.a, {\n        href: \"https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary\",\n        children: \"\\\"why is the service mesh necessary\\\"\"\n      }), \".\\nInterestingly, in many hype-y articles on the Internet this context is\\noften forgotten, or omitted.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Solving a problem well, even if it’s a problem that a lot of people\\nhave, doesn’t magically provide the tech with a lot of hype. There is\\nalways a sponsor behind it. I don’t know who the sponsor was here, and\\nI’m going to speculate, but it’s hard to sell an RPC library in the\\nworld where open source is a fundamental requirement. There is no clear\\nbusiness model there, that’s why most of the mature RPC libraries were\\nopen-sourced by large tech companies for which it’s not a part of the\\ncore business model. A library is just code, not a piece of\\ninfrastructure. Service meshes are a different story. It’s an isolated\\nnon-trivial piece of infrastructure. As a vendor, not only can you\\nprovide consultancy around the configuration and deployment, but you can\\nalso sell complete hosted solutions around it.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"disillusionments\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#disillusionments\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Disillusionments\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Now that we’ve established the problems, the solution, and most\\nimportantly, the context in which the solution was made, let’s take a\\nlook at the alternatives. The most obvious one, in the spirit of KISS,\\nis to use an RPC library for your preferred language. Here is where the\\ncontext is crucial: if you have a large fleet of services, each written\\nin its own language/ecosystem, and the only language that they share is\\nHTTP then having a single shared RPC library is going to be hard.\\nPerhaps, you’ve got a fabric of deployed and running services, but\\neveryone is afraid of touching them, no one knows how they work, and\\neach redeploy is an adventure. A service mesh is here to help you,\\nbecause at least you’ll be able to roll out new infrastructure features\\nto the mesh regularly.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"On the other hand, if you have a fleet of healthy services written in a\\nsingle application stack, then it’s a good idea to think twice before\\nintroducing a service mesh. By simply introducing or evolving a shared\\nRPC library, you’ll get the exact same benefits and avoid dealing with\\nthe downsides of maintaining service meshes. By studying the service\\nmesh limitations thoroughly, you can avoid finding yourself in the\\ntrough of disillusionment.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/servicemesh/curve.png\",\n        alt: \"Hype Cycle\"\n      })\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"different-ecosystem\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#different-ecosystem\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Different ecosystem\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The ecosystem of the service mesh of your choice will likely be\\ndifferent from the ecosystem of your services. Beautiful websites always\\nmake you believe that the solution is plug’n'play, always works and\\nnever goes down. In reality, sooner or later problems, bugs, quirks in\\nbehaviour will reveal themselves, as they always do. At that point,\\nyou’ll need to have engineers who work on the service-mesh’s ecosystem\\nwhich when it’s different from the main app, effectively limits the set\\nof people who can introduce changes or fix problems. This is likely to\\nreintroduce silos, which is against the whole DevOps spirit. Yes, having\\na DevOps team of engineers who are doing DevOps-y things \", _jsx(_components.a, {\n        href: \"https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/\",\n        children: \"is against\\nDevOps\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"unnecessary-overhead\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#unnecessary-overhead\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Unnecessary overhead\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Not only having a proxy in front of each service adds overhead (often\\nsignificant, talking about\\n\", _jsx(_components.a, {\n        href: \"https://istio.io/latest/docs/ops/deployment/performance-and-scalability/\",\n        children: \"90pt\"\n      }), \"\\nrather than 99pt in the performance summary \", _jsx(_components.a, {\n        href: \"https://www.infoq.com/presentations/latency-response-time/\",\n        children: \"doesn’t make software run\\nfaster\"\n      }), \") and\\nconsumes resources, but you also requires time (or rather a team of\\npeople) to manage them. Yes, it can help to make some of the tasks\\npotentially easier - yay, you can now add canary deployments with a few\\nlines of YAML to simple applications now. However, you still need to\\nmanage canary deployments of the proxies themselves which don’t have a\\nproxy in front of them. The problems just get pushed up the stack.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"limiting-your-architecture-to-what-the-proxy-supports\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#limiting-your-architecture-to-what-the-proxy-supports\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Limiting your architecture to what The Proxy supports.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As you’re reading this paragraph, HTTP/3 is slowly being rolled out to\\nthe Internet. It uses UDP as transport. Why use UDP rather than create a\\ncompletely new protocol you ask? That’s because anything but TCP and UDP\\nis simply “blocked” by the boxes, various proxies on the internet -\\nrouters, gateways, etc. This phenomenon got named\\n\", _jsx(_components.a, {\n        href: \"https://http3-explained.haxx.se/en/why-quic/why-ossification\",\n        children: \"ossification\"\n      }), \".\\nSo, only TCP or UDP are left is the practical chose, and even UDP is\\npartially blocked by various corporate proxies which slows down the\\nadoption.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Even though your microservice environment is probably much smaller\\ncompared to the Internet, you can draw parallels with service meshes.\\nProxies can ossify your application architecture by limiting how your\\nservices talk to each other, and there is not much benefit in having\\nproxies if you can bypass them. Suppose you want to build a reactive\\napplication which is using RSocket over pure tcp? Or perhaps a\\nmessage-driven application using an actor model? Or maybe push the\\nperformance boundaries with Aeron? Not going to happen until the box in\\nthe middle becomes aware of the protocol.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"do-i-need-one\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#do-i-need-one\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Do I need one?\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"What does it all mean for you as an engineer? The answer to whether you\\nneed to adopt the service mesh approach comes down to the state of the\\nmicroservice environment you’re trying to improve. As we have\\nestablished, compared to an RPC framework, service meshes allow you to:\"\n    }), \"\\n\", _jsxs(_components.ol, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"Deploy the infra changes more often than deploying your services.\"\n      }), \"\\n\", _jsx(_components.li, {\n        children: \"Introduce infra changes without touching the service code.\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The point 1. is important when for whatever reason you can’t redeploy\\nyour services very often, e.g. maybe no one remembers how it’s done\\nanymore, or maybe there are other restrictions. The point 2. is\\nimportant when your stack is heterogeneous, e.g. some services are built\\nin Go, some in Java, some in Haskell, etc. Where are you on the interval\\nfrom a huge set of heterogeneous services with unknown deployment\\nschedules to a set of homogenous regularly deployed services defines\\nwhether a service mesh is the best solution for you.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"conclusion\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#conclusion\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Conclusion\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Service meshes have a lot of hype around them, and way too much in my\\nopinion. However, before committing to a piece of technology, it’s\\ncrucial to understand the problems it solves, and the context in which\\nthe solution was made. A service mesh is not an ultimate “good practice”\\nbut simply one of the patterns to solve a set of issues, and it’s quite\\na heavy one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Rather than jumping on board, look carefully - the last thing you want\\nis to find out that you have invested in a solution for a problem that\\nyou don’t have. Service meshes are an amazing piece of tech solving a\\nwhole lot of problems. Not in every case, it is the best solution.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"thank-you-to\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#thank-you-to\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Thank you to\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: \"You for reading this article.\"\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [_jsx(_components.a, {\n          href: \"https://twitter.com/ptuls\",\n          children: \"Paul Tune\"\n        }), \" for reviewing the article.\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"references\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#references\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"References\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://eng.lyft.com/envoy-7-months-later-41986c2fd443\",\n          children: \"https://eng.lyft.com/envoy-7-months-later-41986c2fd443\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://github.com/linkerd/linkerd/\",\n          children: \"https://github.com/linkerd/linkerd/\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://servicemesh.io/\",\n          children: \"https://servicemesh.io/\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/\",\n          children: \"https://continuousdelivery.com/2012/10/theres-no-such-thing-as-a-devops-team/\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://http3-explained.haxx.se/en/why-quic/why-ossification\",\n          children: \"https://http3-explained.haxx.se/en/why-quic/why-ossification\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary\",\n          children: \"https://linkerd.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/#why-is-the-service-mesh-necessary\"\n        })\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"discuss-on\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#discuss-on\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Discuss on\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://twitter.com/SerCeMan/status/1286242507664191488\",\n          children: \"Twitter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://news.ycombinator.com/item?id=25148642\",\n          children: \"Hacker News\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"You don't need no Service Mesh","description":"Empty","date":"2020-07-23"}},"frontMatter":{"title":"You don't need no Service Mesh","description":"Empty","date":"2020-07-23"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"23-07-2020-you-dont-need-no-service-mesh"},"buildId":"DXtfXN-a50Sw3EddhgVEM","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>