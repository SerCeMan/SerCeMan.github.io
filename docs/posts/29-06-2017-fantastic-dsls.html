<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Fantastic DSLs and where to find them - Hunter Chang</title><meta content="Empty" name="description"/><meta property="og:url" content="https://nextjs-typescript-mdx-blog.vercel.app/posts/29-06-2017-fantastic-dsls"/><link rel="canonical" href="https://nextjs-typescript-mdx-blog.vercel.app/posts/29-06-2017-fantastic-dsls"/><meta property="og:type" content="article"/><meta property="og:site_name" content="Fantastic DSLs and where to find them - Hunter Chang"/><meta property="og:description" content="Empty"/><meta property="og:title" content="Fantastic DSLs and where to find them - Hunter Chang"/><meta property="og:image" content="https://serce.meundefined"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:site" content="@huntarosan"/><meta name="twitter:title" content="Fantastic DSLs and where to find them - Hunter Chang"/><meta name="twitter:description" content="Empty"/><meta name="twitter:image" content="https://serce.meundefined"/><meta property="article:published_time" content="2017-06-29"/><meta name="next-head-count" content="17"/><link rel="preload" href="/_next/static/css/85ebde2875f9a2f0.css" as="style"/><link rel="stylesheet" href="/_next/static/css/85ebde2875f9a2f0.css" data-n-g=""/><link rel="preload" href="/_next/static/css/6356dc4d41292890.css" as="style"/><link rel="stylesheet" href="/_next/static/css/6356dc4d41292890.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-6108e5f9f07f1e88.js" defer=""></script><script src="/_next/static/chunks/framework-114634acb84f8baa.js" defer=""></script><script src="/_next/static/chunks/main-cc30d3db21e1456f.js" defer=""></script><script src="/_next/static/chunks/pages/_app-d4bf991221a140f0.js" defer=""></script><script src="/_next/static/chunks/660-110f10b88868d913.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bslug%5D-3206bcd67143127b.js" defer=""></script><script src="/_next/static/3sWW6Mm9mumttKqNI3vIa/_buildManifest.js" defer=""></script><script src="/_next/static/3sWW6Mm9mumttKqNI3vIa/_ssgManifest.js" defer=""></script></head><body style="background-color:#f2f2f2" class="bg-white text-gray-900 dark:text-white"><div id="__next"><script>!function(){try{var d=document.documentElement,c=d.classList;c.remove('light','dark');var e=localStorage.getItem('theme');if(e){c.add(e|| '')}else{c.add('light');}if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'light'}catch(t){}}();</script><header style="background-color:#f8f8f8" class="relative shadow-md"><div class="max-w-5xl px-8 py-1 mx-auto"><div class="flex items-center justify-between"><nav class="flex justify-between items-center w-full text-lg"><a style="font-family:Alegreya" class="text-gray-500 pr-6 py-4 float-left w-1/2 text-4xl" href="/">SerCe&#x27;s blog</a><div class="float-right"><a class="text-gray-600 px-6 py-4" href="/">Home</a><a class="text-gray-600 px-6 py-4" href="/blog">Blog</a></div></nav></div></div></header><main><div><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/styles/default.min.css"/><article class="container mx-auto mt-12 px-10 py-8 shadow-md bg-white max-w-5xl flex flex-col"><p class="self-start text-sm text-gray-500">29 June 2017</p><div class="asciiprose"><h1 class="text-gray-900">Fantastic DSLs and where to find them</h1><p>Hi!</p>
<p>Kotlin is a very rich language. Unlike many other languages, it allows
developers to create another language inside it. For example, to mimic
HTML syntax or to build a completely typed SQL query. But Kotlin’s power
isn’t limited to simple DSLs. With some Kotlin-fu, it’s possible to
write a DSL that allows manipulating untyped data structures in a typed
manner. In this article, we’ll go through different ways to define DSL
in Kotlin, from very simple to fantastically powerful.</p>
<p><img src="/images/fantastic/kotlin_island.png" alt=""/></p>
<div class="quoteblock"><blockquote><div class="paragraph"><p>Peter the Great at one time even considered moving the capital of
Russia to Kotlin Island, proof of the sovereign’s great affinity with
water. This utopian idea failed, but many of the fantasies of this
baroque autocrat still managed to become implemented.</p></div></blockquote><div></div></div>
<div class="warning"><p>Some parts of this article might be hard to understand without knowledge
of Kotlin syntax. I tried to explain every feature I showed, but the
general ability to speak Kotlin is strongly suggested.</p></div>
<p>So, let’s begin the journey.</p>
<h2 id="what-is-s-dsl"><a class="anchor" href="#what-is-s-dsl"><span class="icon icon-link"></span></a>What is s DSL</h2>
<blockquote>
<p>Domain-specific language (noun): a computer programming language of
limited expressiveness focused on a particular domain</p>
<p>—  Martin Fowler Domain-Specific Languages</p>
</blockquote>
<p>Here though, I prefer to give DSLs a slightly different definition which
reflects what is written in the article</p>
<blockquote>
<p>a language (or a set of abstractions) that’s built to deal with a
specific domain</p>
</blockquote>
<p>The main difference is that a DSL might not only be a separate language
but also a subset of a language which is used to work on a specific
domain. This kind of DSL can even be built in Java with some fluent API,
but very often it’s indistinguishable from a plain good code. To
contrast in Kotlin, many remarkable features might make an internal DSL
look different.</p>
<h2 id="calling-convention"><a class="anchor" href="#calling-convention"><span class="icon icon-link"></span></a>Calling convention</h2>
<p>The first feature actively used by DSLs in Kotlin is a special calling
convention. If the last parameter of a method is a function, and you’re
passing a lambda expression there, you can specify it outside of
parentheses.</p>
<p>For example, if one wants to create a function <code>dotimes</code> that takes a
number <code>n</code>, a function <code>f</code> and applies it, the easiest way to do that is</p>
<div class="formalpara-title"><p><strong>good old dotimes</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">dotimes</span><span class="hljs-params">(n: <span class="hljs-type">Int</span>, f: () -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-keyword">for</span> (i <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.n-<span class="hljs-number">1</span>) {
        f()
    }
}
</code></pre>
<p>The <code>dotimes</code> can be called in this way</p>
<pre><code class="hljs language-kotlin">dotimes(<span class="hljs-number">5</span>, {
    println(<span class="hljs-string">&quot;Hello, Kotlin!&quot;</span>)
})
</code></pre>
<p>Or, using the lambda parameter convention and placing lambda function
outside parentheses.</p>
<pre><code class="hljs language-kotlin">dotimes(<span class="hljs-number">5</span>) {
    println(<span class="hljs-string">&quot;Hello, Kotlin!&quot;</span>)
}
</code></pre>
<p>Moreover, the parentheses can be omitted completely if a lambda is the
only parameter of a function. E.g. <code>do5times</code> function that only takes a
lambda as a parameter can be defined and called as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">do5times</span><span class="hljs-params">(f: () -&gt; <span class="hljs-type">Unit</span>)</span></span> = dotimes(<span class="hljs-number">5</span>, f)

do5times {
    println(<span class="hljs-string">&quot;Hello, Kotlin!&quot;</span>)
}
</code></pre>
<p>But despite being important, that calling convention is just a tiny
contribution to DSLs when compared to extension functions.</p>
<h2 id="extension-functions"><a class="anchor" href="#extension-functions"><span class="icon icon-link"></span></a>Extension functions</h2>
<p>Extension functions simply allow you to extend the functionality of a
class from the outside.</p>
<div class="formalpara-title"><p><strong>Simple extension function</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">removeSpaces</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.filter({ c -&gt; c != <span class="hljs-string">&#x27; &#x27;</span> })
}

print(<span class="hljs-string">&quot;Hi ! , ext&quot;</span>.removeSpaces()) <span class="hljs-comment">// &quot;Hi!,ext&quot;</span>
</code></pre>
<p>Here, the <code>removeSpace</code> function is defined on the class String which
enables an ability to call <code>removeSpaces</code> on any <code>String</code> instance.
Unsurprisingly, it removes all the spaces from it. Inside the functions,
<code>this</code> refers to the instance of a receiver class and can be omitted
like you do when you’re writing a member function. That might sound
complicated if you have never heard about extension functions before,
but looking at the result of the compilation might make it much easier
to understand.</p>
<div class="formalpara-title"><p><strong>Decompiled java code</strong></p></div>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">removeSpaces</span><span class="hljs-params">(String $receiver)</span> {
  <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; $receiver.length(); i++) {
    <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> $receiver.charAt(i);
    <span class="hljs-keyword">if</span> (c != <span class="hljs-string">&#x27; &#x27;</span>) {
      sb.append(c);
    }
  }
  <span class="hljs-keyword">return</span> sb.toString();
}
</code></pre>
<p>Extension functions are not some kind of magic. It’s not a Groovy-like
monkey patching, they get compiled to simple static functions. But that
example shows us a very important caveat - extension functions are
resolved statically because there is no dispatch mechanism for static
methods</p>
<p>Even though this snippet is very simple, it can raise another question -
&quot;where did the <code>StringBuilder</code> came from?&quot;. An close look at the first
snippet through <code>Java</code> glasses gives the answer - there is no function
called <code>filter</code> defined in the class String. <code>filter</code> is also an
extension function defined in the Kotlin standard library.</p>
<div class="formalpara-title"><p><strong>filter function from kotlin stdlib</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">public</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">filter</span><span class="hljs-params">(predicate: (<span class="hljs-type">Char</span>) -&gt; <span class="hljs-type">Boolean</span>)</span></span>: String {
  <span class="hljs-keyword">val</span> destination = StringBuilder()
  <span class="hljs-keyword">for</span> (index <span class="hljs-keyword">in</span> <span class="hljs-number">0.</span>.length - <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">val</span> element = <span class="hljs-keyword">get</span>(index)
    <span class="hljs-keyword">if</span> (predicate(element))
      destination.append(element)
  }
  <span class="hljs-keyword">return</span> destination.toString()
}
</code></pre>
<p>Kotlin defines a lot of extension functions for Java classes in the
standard library. That’s why Kotlin is so convenient to use. One might
notice that the function has an <code>inline</code> modifier on it which explains
why decompiled <code>removeSpaces</code> has a <code>StringBuilder</code> inside and not a
call to <code>filter</code>.</p>
<p>Many newcomers to Kotlin use the <code>inline</code> modifier everywhere under the
impression that inlining can improve performance. It can, but in many
cases, inline functions don’t improve performance at all, they even can
make it worse. There is an inspection for that in IntelliJ IDEA.</p>
<p><img src="/images/fantastic/inspection.png" alt=""/></p>
<p>There are also some other uses for <code>inline</code> which can be found in
<a href="https://kotlinlang.org/docs/reference/inline-functions.html">docs</a>.</p>
<h3 id="extension-function-on-generic-type"><a class="anchor" href="#extension-function-on-generic-type"><span class="icon icon-link"></span></a>Extension function on generic type</h3>
<p>The Kotlin compiler is smart enough to allow for the definition of
extension functions on a certain generic type. In this example,
<code>toIntArray</code> function can be called only on a collection that contains
integers. This makes extension functions truly unique, there is no way
(without subclassing) to define a method for <code>Collection</code> class that can
be called only on an <code>Int</code> collection.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> Collection<span class="hljs-type">&lt;Int&gt;</span>.<span class="hljs-title">toIntArray</span><span class="hljs-params">()</span></span>: IntArray {
  <span class="hljs-keyword">val</span> result = IntArray(size)
  <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> (element <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>)
    result[index++] = element
  <span class="hljs-keyword">return</span> result
}
</code></pre>
<pre><code class="hljs language-kotlin">listOf(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).toIntArray()       <span class="hljs-comment">// works</span>
listOf(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>).toIntArray() <span class="hljs-comment">// type error</span>
</code></pre>
<p>If Kotlin has become your native language, you might be wondering now,
why I’m talking about these simple features in an article about DSLs.
The thing is, the majority of Kotlin DSLs are based on the
expressiveness of the two features mentioned above.</p>
<h3 id="first-simple-dsl"><a class="anchor" href="#first-simple-dsl"><span class="icon icon-link"></span></a>First simple DSL</h3>
<p>Given the aforementioned features, it’s very easy to write a first very
simple DSL.</p>
<p>Let’s say we need to write an event-based droid fighting platform so
that users can provide their own strategies and register them on the
platform. For each event the user is interested in, they must provide a
callback with the droid’s behaviour. A droid has an interface with a few
methods for defeating other droids. Or, humans if you will.</p>
<div class="formalpara-title"><p><strong>the droid</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Droid</span> {
  <span class="hljs-keyword">val</span> peopleAround: <span class="hljs-built_in">Boolean</span>
  <span class="hljs-keyword">val</span> gun: Gun

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">fire</span><span class="hljs-params">(gun: <span class="hljs-type">Gun</span>)</span></span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveLeft</span><span class="hljs-params">()</span></span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">moveRight</span><span class="hljs-params">()</span></span>
}
</code></pre>
<p>This sounds like an ideal case for DSL and now we need to define a
public API which the clients will be happy to use. To provide the
droid’s behaviour we’ll write a public function.</p>
<div class="formalpara-title"><p><strong>API</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> droid: Droid = getDroid() <span class="hljs-comment">// inaccessible from the public API</span>

<span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">on</span><span class="hljs-params">(cmd: <span class="hljs-type">String</span>, f: <span class="hljs-type">Droid</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> {
<span class="hljs-comment">// ...</span>
  droid.f()
<span class="hljs-comment">// ...</span>
}
</code></pre>
<p>The type of the argument <code>f</code> might look weird, but it’s just the type of
0-arity extension function on the type Droid. And finally, the APIs
consumers can register events in the platform.</p>
<div class="formalpara-title"><p><strong>strategy example</strong></p></div>
<pre><code class="hljs language-kotlin">on(<span class="hljs-string">&quot;back&quot;</span>) {
  moveLeft()
  <span class="hljs-keyword">if</span> (peopleAround) {
    fire(gun)
  }
}
</code></pre>
<p>Here, the anonymous extension function is a second parameter and
therefore can be written outside parentheses. <code>this</code> in the function has
a type <code>Droid</code> and therefore <code>moveLeft()</code> as well as other functions and
properties can be called by themselves without providing an explicit
receiver type..</p>
<p>The strategy looks very natural, it clearly says that if our droid
receives a <code>back</code> command, it should move left and try to shoot some
folks around him. The next snippet shows to what it can be compiled to
in order to make it even clearer for those who don’t speak kotlin well
yet.</p>
<div class="formalpara-title"><p><strong>decompiled java call</strong></p></div>
<pre><code class="hljs language-java">on(<span class="hljs-string">&quot;back&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function1</span>&lt;Droid, Unit&gt;() {
  <span class="hljs-keyword">public</span> Unit <span class="hljs-title function_">invoke</span><span class="hljs-params">(Droid droid)</span> {
    droid.moveLeft();
    <span class="hljs-keyword">if</span> (droid.getPeopleAround()) {
      droid.fire(droid.getGun());
    }
    <span class="hljs-keyword">return</span> Unit.INSTANCE;
  }
});
</code></pre>
<h2 id="html-builders"><a class="anchor" href="#html-builders"><span class="icon icon-link"></span></a>HTML builders</h2>
<p>Building DSLs using extension functions isn’t limited to simple droid
fighting strategies. For example, it allows us to build a completely
typed HTML syntax; HTML builders are even mentioned in the <a href="https://kotlinlang.org/docs/reference/type-safe-builders.html">official
documentation</a>.</p>
<div class="formalpara-title"><p><strong>html builders</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> list = listOf(<span class="hljs-string">&quot;Kotlin&quot;</span>, <span class="hljs-string">&quot;is&quot;</span>, <span class="hljs-string">&quot;awesome&quot;</span>)
<span class="hljs-keyword">val</span> result: HTML =
  html {
    head {
      title { +<span class="hljs-string">&quot;HTML DSL in Kotlin&quot;</span> }
    }
    body {
      p {
        +<span class="hljs-string">&quot;a line about Kotlin&quot;</span>
      }
      a(href = <span class="hljs-string">&quot;jetbrains.com/kotlin&quot;</span>) {
        +<span class="hljs-string">&quot;Kotlin&quot;</span>
      }
      p {
        +<span class="hljs-string">&quot;Kotlin is:&quot;</span>
        ul {
          <span class="hljs-keyword">for</span> (arg <span class="hljs-keyword">in</span> list)
            li { +arg }
        }
      }
    }
  }
println(result)
</code></pre>
<p>And these type-safe builders aren’t a Kotlin invention, on the JVM land
they were originated in Groovy. But Groovy is a dynamic language,
builders there are not type-safe.</p>
<div class="important"><p>It wouldn’t be completely fair to say that even though it’s what
Kotlin’s documentation says, Groovy supports static compilation
optionally and there are some ways to compile builders statically as
well.</p></div>
<p>The implementation of a DSL in dynamically typed languages is often very
different to statically typed languages. In Kotlin, in order to build a
DSL, you need to describe the whole schema of the future language. And
given that the result is a deeply nested data structure, the easiest way
to convert it to string is to traverse the whole data-structure
recursively.</p>
<div class="formalpara-title"><p><strong>base interface</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(builder: <span class="hljs-type">StringBuilder</span>, indent: <span class="hljs-type">String</span>)</span></span>
}
</code></pre>
<p>The simplest line of text can be represented as</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextElement</span>(<span class="hljs-keyword">val</span> text: String) : Element {
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(builder: <span class="hljs-type">StringBuilder</span>, indent: <span class="hljs-type">String</span>)</span></span> {
    builder.append(<span class="hljs-string">&quot;<span class="hljs-variable">$indent</span><span class="hljs-variable">$text</span>\n&quot;</span>)
  }
}
</code></pre>
<p>The real tag representation is a bit more complex</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>(<span class="hljs-keyword">val</span> name: String) : Element {
  <span class="hljs-keyword">val</span> children = arrayListOf&lt;Element&gt;()
  <span class="hljs-keyword">val</span> attributes = hashMapOf&lt;String, String&gt;()

  <span class="hljs-comment">// open tag</span>
  <span class="hljs-comment">// render attributes</span>
  <span class="hljs-comment">// render children recursively</span>
  <span class="hljs-comment">// close tag</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">render</span><span class="hljs-params">(builder: <span class="hljs-type">StringBuilder</span>, indent: <span class="hljs-type">String</span>)</span></span> {
    builder.append(<span class="hljs-string">&quot;<span class="hljs-variable">$indent</span>&lt;<span class="hljs-variable">$name</span><span class="hljs-subst">${renderAttributes()}</span>&gt;\n&quot;</span>)
    <span class="hljs-keyword">for</span> (c <span class="hljs-keyword">in</span> children) {
      c.render(builder, indent + <span class="hljs-string">&quot;  &quot;</span>)
    }
    builder.append(<span class="hljs-string">&quot;<span class="hljs-variable">$indent</span>&lt;/<span class="hljs-variable">$name</span>&gt;\n&quot;</span>)
  }

  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">renderAttributes</span><span class="hljs-params">()</span></span> = attributes.map { (k, v) -&gt; <span class="hljs-string">&quot; <span class="hljs-variable">$k</span>=\&quot;<span class="hljs-variable">$v</span>\&quot;&quot;</span> }.joinToString(<span class="hljs-string">&quot;&quot;</span>)

  <span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T : Element&gt;</span> <span class="hljs-title">initTag</span><span class="hljs-params">(tag: <span class="hljs-type">T</span>, <span class="hljs-keyword">init</span>: <span class="hljs-type">T</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    tag.<span class="hljs-keyword">init</span>()
    children.add(tag)
  }

  <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> String.<span class="hljs-title">unaryPlus</span><span class="hljs-params">()</span></span> {
    children.add(TextElement(<span class="hljs-keyword">this</span>))
  }

  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>: String {
    <span class="hljs-keyword">val</span> builder = StringBuilder()
    render(builder, <span class="hljs-string">&quot;&quot;</span>)
    <span class="hljs-keyword">return</span> builder.toString()
  }
}
</code></pre>
<p>It contains a representation of attributes and a set of children. But
the main part that requires attention is the <code>initTag</code> function which
looks very similar to the function <code>on</code> from the &quot;robot fighting&quot; DSL
definition.</p>
<p>Another interesting part is an extension function <code>unaryPlus</code> defined as
an operator for class String inside the <code>Tag</code>. It allows us to use a
convenient (but let’s be honest not obvious at all) way to insert a line
of text inside code like:</p>
<div class="formalpara-title"><p><strong>¯\_(ツ)_/¯ unary plus to append a line of text</strong></p></div>
<pre><code class="hljs language-kotlin">body {
  +<span class="hljs-string">&quot;just a random line&quot;</span>
  +<span class="hljs-string">&quot;another line&quot;</span>
}
</code></pre>
<p>And the rest of the DSL is an enumeration of all possible tags.</p>
<div class="formalpara-title"><p><strong>&lt;head&gt;,&lt;title&gt;,&lt;body&gt;,&lt;a&gt;,&lt;ul&gt;,&lt;li&gt;,&lt;p&gt;</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HTML</span> : <span class="hljs-type">Tag</span>(<span class="hljs-string">&quot;html&quot;</span>) {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">Head</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(Head(), <span class="hljs-keyword">init</span>)

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">body</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">Body</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(Body(), <span class="hljs-keyword">init</span>)
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Head</span> : <span class="hljs-type">Tag</span>(<span class="hljs-string">&quot;head&quot;</span>) {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">title</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">Title</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(Title(), <span class="hljs-keyword">init</span>)
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Title</span> : <span class="hljs-type">Tag</span>(<span class="hljs-string">&quot;title&quot;</span>)

<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BodyTag</span>(name: String) : Tag(name) {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">P</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(P(), <span class="hljs-keyword">init</span>)
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">ul</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">UL</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(UL(), <span class="hljs-keyword">init</span>)
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">a</span><span class="hljs-params">(href: <span class="hljs-type">String</span>, <span class="hljs-keyword">init</span>: <span class="hljs-type">A</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> {
    <span class="hljs-keyword">val</span> a = A()
    initTag(a, <span class="hljs-keyword">init</span>)
    a.href = href
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Body</span> : <span class="hljs-type">BodyTag</span>(<span class="hljs-string">&quot;body&quot;</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">UL</span> : <span class="hljs-type">BodyTag</span>(<span class="hljs-string">&quot;ul&quot;</span>) {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">li</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">LI</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(LI(), <span class="hljs-keyword">init</span>)
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">LI</span> : <span class="hljs-type">BodyTag</span>(<span class="hljs-string">&quot;li&quot;</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">P</span> : <span class="hljs-type">BodyTag</span>(<span class="hljs-string">&quot;p&quot;</span>)

<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> : <span class="hljs-type">BodyTag</span>(<span class="hljs-string">&quot;a&quot;</span>) {
  <span class="hljs-keyword">var</span> href: String
    <span class="hljs-keyword">get</span>() = attributes[<span class="hljs-string">&quot;href&quot;</span>] ?: <span class="hljs-string">&quot;&quot;</span>
    <span class="hljs-keyword">set</span>(value) {
      attributes[<span class="hljs-string">&quot;href&quot;</span>] = value
    }
}
</code></pre>
<p>As you can see, all these classes define a possible hierarchy of calls.
This DSL is just a toy DSL, and therefore it covers a very small and
limited subset of HTML. It is extremely tedious to write the whole HTML
DSL manually. The actual <a href="https://github.com/Kotlin/kotlinx.html">HTML DSL
implementation</a> uses a real <a href="https://github.com/Kotlin/kotlinx.html/blob/master/generate/src/main/resources/html_5.xsd">XSD
schema</a>
to generate all possible classes for the DSL.</p>
<h3 id="there-is-always-a-problem"><a class="anchor" href="#there-is-always-a-problem"><span class="icon icon-link"></span></a>There is always a problem</h3>
<p>This could already be awesome, but the example demonstrates a very weird
behaviour — nobody stops you from defining tags inside each other
multiple times.</p>
<div class="formalpara-title"><p><strong>the problem</strong></p></div>
<pre><code class="hljs language-kotlin">head {
  head {
    head {
      <span class="hljs-comment">// stil possible to write head because implicit receiver html is available</span>
    }
  }
  title { +<span class="hljs-string">&quot;XML encoding with Kotlin&quot;</span> }
}
</code></pre>
<p>Prior to Kotlin 1.1, the only solution was to redefine function with
deprecation.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Head</span> : <span class="hljs-type">Tag</span>(<span class="hljs-string">&quot;head&quot;</span>) {
  <span class="hljs-meta">@Deprecated(message = <span class="hljs-string">&quot;wrong scope&quot;</span>, level = DeprecationLevel.ERROR)</span>
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">head</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">Head</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(Head(), <span class="hljs-keyword">init</span>)

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">title</span><span class="hljs-params">(<span class="hljs-keyword">init</span>: <span class="hljs-type">Title</span>.() -&gt; <span class="hljs-type">Unit</span>)</span></span> = initTag(Title(), <span class="hljs-keyword">init</span>)
}
</code></pre>
<p><img src="/images/fantastic/err1.png" alt=""/></p>
<p>The problem with this approach is that it requires an incredible amount
of boilerplate and a full understanding of all possible combinations. In
1.1,
<a href="https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md">KEEP-57</a>
introduced an alternative to that approach: the <code>@DslMarker</code> annotation
was introduced which allows us to define a <code>DSL marker</code> and introduces a
set of rules for classes annotated with that marker:</p>
<ul>
<li>
<p>an implicit receiver may belong to a DSL if marked with a
corresponding DSL marker annotation</p>
</li>
<li>
<p>two implicit receivers of the same DSL are not accessible in the same
scope</p>
</li>
<li>
<p>the closest one wins</p>
</li>
<li>
<p>other available receivers are resolved as usual, but if the resulting
resolved call binds to such a receiver, it’s a compilation error</p>
</li>
</ul>
<p>So, the HTML DSL can be fixed by introducing a <code>@HtmlTagMarker</code> DSL
marker and annotating <code>Tag</code> with it.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-meta">@HtmlTagMarker</span>
<span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tag</span>(<span class="hljs-keyword">val</span> name: String) : Element {
 <span class="hljs-comment">// ...</span>
}
</code></pre>
<p><img src="/images/fantastic/err2.png" alt=""/></p>
<p>DSLs that give us an ability to construct nested data structures such as
HTML builders, different configurations, UI builders, etc. is where
Kotlin really shines. Kotlin took an awesome idea from Groovy and made
it safe and easy to use.</p>
<p>There are a few more examples of DSLs of that kind:</p>
<ul>
<li>
<p><a href="http://blog.jetbrains.com/teamcity/2016/11/kotlin-configuration-scripts-an-introduction/">TeamCity
DSL</a></p>
</li>
<li>
<p><a href="http://github.com/gradle/gradle-script-kotlin">Gradle with Kotlin</a></p>
</li>
<li>
<p><a href="http://github.com/gradle/gradle-script-kotlin">Anko</a></p>
</li>
<li>
<p><a href="http://spekframework.org">Spek framework</a></p>
</li>
</ul>
<p>But unsurprisingly, it’s not the only type of DSL that can be
implemented in Kotlin…</p>
<h2 id="fantastic-dsl"><a class="anchor" href="#fantastic-dsl"><span class="icon icon-link"></span></a>Fantastic DSL</h2>
<p>Not all domains are born the same. Let’s consider a completely different
domain. A system which handles transactions containing a payment in some
currency and two people - a sender and a receiver.</p>
<p><img src="/images/fantastic/domain.svg" alt=""/></p>
<p>The transaction structure has to be immutable to make it safer. But
sometimes, we might need to create a new transaction with an updated
field. For example, the name of the receiver (from) person might need to
be changed to let’s say &quot;John&quot;. There are a few ways to implement that
in Kotlin</p>
<h3 id="data-classes"><a class="anchor" href="#data-classes"><span class="icon icon-link"></span></a>Data classes</h3>
<p>Let’s start with an idiomatic Kotlin way. The class hierarchy can be
concisely represented as</p>
<div class="formalpara-title"><p><strong>data</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transaction</span>(<span class="hljs-keyword">val</span> payment: Payment, <span class="hljs-keyword">val</span> parts: Parts)
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Payment</span>(<span class="hljs-keyword">val</span> currency: String, <span class="hljs-keyword">val</span> amount: <span class="hljs-built_in">Int</span>)
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Parts</span>(<span class="hljs-keyword">val</span> from: Person, <span class="hljs-keyword">val</span> to: Person)
<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>(<span class="hljs-keyword">val</span> id: <span class="hljs-built_in">Int</span>, <span class="hljs-keyword">val</span> name: String)
</code></pre>
<p>An instance of the <code>Transaction</code> can easily be created as well</p>
<div class="formalpara-title"><p><strong>create</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> trs = Transaction(
  Payment(<span class="hljs-string">&quot;AUD&quot;</span>, <span class="hljs-number">15</span>),
  Parts(
    Person(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;Alex&quot;</span>),
    Person(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;Ben&quot;</span>)
  )
)
</code></pre>
<p>But problems start when we need to update this nested data structure.
Generally, there two ways to do that. The first option is to completely
recreate the transaction which doesn’t look good.</p>
<div class="formalpara-title"><p><strong>update [1]</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> trans = Transaction(trs.payment, Parts(
  Person(trs.parts.from.id, <span class="hljs-string">&quot;John&quot;</span>),
  trs.parts.to)
)
</code></pre>
<p>Another is to use
<a href="https://kotlinlang.org/docs/reference/data-classes.html#copying">copy</a></p>
<div class="formalpara-title"><p><strong>update [2]</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stansTrs2 = trs.copy(
  parts = trs.parts.copy(
    from = trs.parts.from.copy(
      name = <span class="hljs-string">&quot;John&quot;</span>
    )
  )
)
</code></pre>
<p>And the copy version doesn’t look good either. Even though it’s
tolerable now, the bigger the data structure, the uglier the code look
like. On a deeply nested immutable data structure, it looks like a
triangle instead of a simple call chain from the mutable world.</p>
<div class="formalpara-title"><p><strong>ohhhh</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> stansTrs2 = trs.copy(
  parts = trs.parts.copy(
    from = trs.parts.from.copy(
      person = trs.parts.from.person.copy(
        parts = trs.parts.from.person.parts.copy(
          from = trs.parts.from.person.parts.from.copy(
            person = trs.parts.from.person.parts.from.person.copy(
              parts = trs.parts.from.person.parts.from.person.parts.copy(
                from = trs.parts.from.person.parts.from.person.parts.from.copy(
                  person = trs.parts.from.person.parts.from.person.parts.from.person.copy(
                    parts = trs.parts.from.person.parts.from.person.parts.from.person.parts.copy(
                      from = trs.parts.from.person.parts.from.person.parts.from.person.parts.from.copy(
                        name = <span class="hljs-string">&quot;jonh&quot;</span>
                      ))))))))))))
</code></pre>
<p>Don’t get me wrong, I like parentheses. It feels like a lisp (which I
like a lot), but what no one likes is the wall of boilerplate above.</p>
<h3 id="persistent-data-structures"><a class="anchor" href="#persistent-data-structures"><span class="icon icon-link"></span></a>Persistent Data Structures</h3>
<p>But talking about lisps, there is another awesome language called
Clojure. It’s a lisp running on JVM where every data structure is
persistent (don’t confuse with
<a href="https://stackoverflow.com/questions/10034537/persistent-vs-immutable-data-structure">immutable</a>).
In Clojure, the same problem can be solved by defining the transaction
structure as a persistent map.</p>
<div class="formalpara-title"><p><strong>create</strong></p></div>
<pre><code class="hljs language-clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">ts</span> {<span class="hljs-symbol">:payment</span> {<span class="hljs-symbol">:currency</span> <span class="hljs-string">&quot;AUD&quot;</span>
                   <span class="hljs-symbol">:amount</span>   <span class="hljs-number">15</span>}
         <span class="hljs-symbol">:parts</span>   {<span class="hljs-symbol">:from</span> {<span class="hljs-symbol">:id</span>   <span class="hljs-number">0</span>
                          <span class="hljs-symbol">:name</span> <span class="hljs-string">&quot;Alex&quot;</span>}
                   <span class="hljs-symbol">:to</span>   {<span class="hljs-symbol">:id</span>   <span class="hljs-number">1</span>
                          <span class="hljs-symbol">:name</span> <span class="hljs-string">&quot;Ben&quot;</span>}}})
</code></pre>
<p>Not as concise as Kotlin’s version, but still pretty good. What is
completely different to Kotlin, is the update function</p>
<div class="formalpara-title"><p><strong>update</strong></p></div>
<pre><code class="hljs language-clojure">(<span class="hljs-keyword">def</span> <span class="hljs-title">ts2</span> (<span class="hljs-name">assoc-in</span> ts [<span class="hljs-symbol">:parts</span> <span class="hljs-symbol">:from</span> <span class="hljs-symbol">:name</span>] <span class="hljs-string">&quot;John&quot;</span>))
</code></pre>
<p>It’s only one line! And it’s exactly what we aimed for. The next picture
might be essential for understanding how it works.</p>
<p><img src="/images/fantastic/domain_clj.svg" alt=""/></p>
<p>Given that each node has a known type - <code>clojure.lang.APersistentMap</code> -
and the universal way of traversing is <code>map.get(&quot;key&quot;)</code>, it’s possible
to write a function <code>assoc-in</code> which can change a value under a given
&quot;path&quot; and to recreate the data structure <a href="http://cjohansen.no/clojure-to-die-for/">node by
node</a>. But Clojure’s internals
are plain java classes that can be used from Kotlin easily just with a
few &quot;convenience&quot; adapters to keep familiar syntax.</p>
<div class="formalpara-title"><p><strong>create</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> tran = pArrayMap(
  <span class="hljs-string">&quot;payment&quot;</span> to pArrayMap(
    <span class="hljs-string">&quot;currency&quot;</span> to <span class="hljs-string">&quot;AUD&quot;</span>,
    <span class="hljs-string">&quot;amount&quot;</span> to <span class="hljs-number">15</span>
  ),
  <span class="hljs-string">&quot;parts&quot;</span> to pArrayMap(
    <span class="hljs-string">&quot;from&quot;</span> to pArrayMap(
      <span class="hljs-string">&quot;id&quot;</span> to <span class="hljs-number">0</span>,
      <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;Alex&quot;</span>
    ),
    <span class="hljs-string">&quot;to&quot;</span> to pArrayMap(
      <span class="hljs-string">&quot;id&quot;</span> to <span class="hljs-number">1</span>,
      <span class="hljs-string">&quot;name&quot;</span> to <span class="hljs-string">&quot;Ben&quot;</span>
    )
  )
)
</code></pre>
<p>Yes, the creation looks rather ugly. It’s untyped, all the key names are
represented as strings, but let’s look at the update function.</p>
<div class="formalpara-title"><p><strong>update</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> trans2 = trans.pUpdate(listOf(<span class="hljs-string">&quot;parts&quot;</span>, <span class="hljs-string">&quot;from&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>), <span class="hljs-string">&quot;John&quot;</span>)
</code></pre>
<p>It’s still as concise and beautiful as Clojure’s one.</p>
<p>But is it possible to build a DSL which keeps types from Kotlin types
and provides the conciseness of Clojure?</p>
<h2 id="cursor-dsl"><a class="anchor" href="#cursor-dsl"><span class="icon icon-link"></span></a>Cursor DSL</h2>
<p>It is possible! Using a special DSL, you can define the structure of the
&quot;transactional&quot; domain in a following way.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Transaction</span>
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Transaction, F&gt;.payment <span class="hljs-keyword">by</span> Node&lt;Payment&gt;()
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Transaction, F&gt;.parts <span class="hljs-keyword">by</span> Node&lt;Parts&gt;()

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Payment</span>
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Payment, F&gt;.currency <span class="hljs-keyword">by</span> Leaf&lt;String&gt;()
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Payment, F&gt;.amount <span class="hljs-keyword">by</span> Leaf&lt;<span class="hljs-built_in">Int</span>&gt;()

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Parts</span>
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Parts, F&gt;.to <span class="hljs-keyword">by</span> Node&lt;Person&gt;()
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Parts, F&gt;.from <span class="hljs-keyword">by</span> Node&lt;Person&gt;()

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span>
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Person, F&gt;.id <span class="hljs-keyword">by</span> Leaf&lt;<span class="hljs-built_in">Int</span>&gt;()
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Person, F&gt;.name <span class="hljs-keyword">by</span> Leaf&lt;String&gt;()
</code></pre>
<p>This looks scary, but it’s just a bit of necessary boilerplate. This
code should be read like</p>
<p>The creation looks very similar to the untyped version, but it’s
completely typed. It references properties defined above.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> trans = domain&lt;Transaction&gt; {
  (payment) {
    currency.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;AUD&quot;</span>)
    amount.<span class="hljs-keyword">set</span>(<span class="hljs-number">15</span>)
  }
  (parts) {
    (from) {
      id.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>)
      name.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;Alex&quot;</span>)
    }
    (to) {
      id.<span class="hljs-keyword">set</span>(<span class="hljs-number">1</span>)
      name.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;Ben&quot;</span>)
    }
  }
}
</code></pre>
<p>It’s possible to update the transaction easily. And not just one field,
in fact, the code above creates an empty data structure and applies an
update function to it.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> trans2 = trans.cursor.parts.from.update {
  name.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;John&quot;</span>)
}
println(trans.cursor.parts.from.name.value) <span class="hljs-comment">// &quot;Alex&quot;</span>
println(trans2.cursor.parts.from.name.value) <span class="hljs-comment">// &quot;John&quot;</span>
</code></pre>
<p>or</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> trans3 = trans2.cursor.update {
  (payment) {
    currency.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;USD&quot;</span>)
    amount.<span class="hljs-keyword">set</span>(<span class="hljs-number">12</span>)
  }
}
</code></pre>
<p>What is really awesome is that the <code>set</code> function can only be called
inside the <code>update</code> block. It’s possible to think about the <code>update</code>
block as an open transaction where a few updates are applied.</p>
<h3 id="implementation"><a class="anchor" href="#implementation"><span class="icon icon-link"></span></a>Implementation</h3>
<h4 id="read"><a class="anchor" href="#read"><span class="icon icon-link"></span></a>Read</h4>
<p>The easiest way to start implementing it is to imagine that the data
structure is already created and everything we need to do is to read a
value from it. The obvious untyped solution will be to call
<code>trans.get(&quot;parts&quot;).get(&quot;from&quot;).get(&quot;name&quot;)</code>. And this approach works
fine until we need to update it. After the first <code>get</code> call, the
reference to the root transaction is lost and there’ll be no way to run
the update operation.</p>
<p>Instead, it’s possible to focus on the way of traversing the data
structure without loosing the reference to the root. To accomplish this,
it’s possible to implement <code>Focus</code> interface which holds the reference
to the root and accumulates a path inside.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Focus</span>&lt;<span class="hljs-type">out Op</span>&gt; {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">narrow</span><span class="hljs-params">(k: <span class="hljs-type">String</span>)</span></span>: Focus&lt;Op&gt;
  <span class="hljs-keyword">val</span> op: Op
}
</code></pre>
<p>The interesting thing that <code>Focus</code> is parametrised over an operation.
That operation can be <code>Read</code> or <code>Write</code> depending on the context. When a
leaf is reached, the typed version will finally perform an action using
that operation.</p>
<div class="formalpara-title"><p><strong>narrow down the usage</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">val</span> f = Focus(trans)       <span class="hljs-comment">// {&quot;root&quot; -&gt; Transaction, path -&gt; []}</span>
<span class="hljs-keyword">val</span> f2 = f.narrow(<span class="hljs-string">&quot;parts&quot;</span>) <span class="hljs-comment">// {&quot;root&quot; -&gt; Transaction, path -&gt; [&quot;parts&quot;]}</span>
<span class="hljs-keyword">val</span> f3 = f2.narrow(<span class="hljs-string">&quot;from&quot;</span>) <span class="hljs-comment">// {&quot;root&quot; -&gt; Transaction, path -&gt; [&quot;parts&quot;, &quot;from&quot;]}</span>
<span class="hljs-comment">// ...</span>
</code></pre>
<p><img src="/images/fantastic/domain_focus.svg" alt=""/></p>
<p>But even though the focus does its job very well, it’s completely
untyped, and strings have to be used to navigate through. The type must
be stored somewhere. As everyone knows that any problem can be solved
with an additional layer of abstraction! Let’s define a wrapper
parametrised over the type of an underlying node.</p>
<div class="formalpara-title"><p><strong>the missed layer</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cursor</span>&lt;<span class="hljs-type">out T, out Op</span>&gt;(<span class="hljs-keyword">val</span> f: Focus&lt;Op&gt;)
</code></pre>
<p><code>Cursor</code> is parametrised over a node type and the <code>operation</code> is derived
from the focus. And now, the <code>Transaction</code> definition starts making
sense. The narrowing can be delegated to the <code>Node</code> object that knows
the type and uses the name of a property to create a new <code>Cursor</code> with a
new <code>Focus</code> inside.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Transaction</span>
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Transaction, F&gt;.payment <span class="hljs-keyword">by</span> Node&lt;Payment&gt;()
</code></pre>
<p>Here, the <code>payment</code> is an extension property on the <code>Transaction</code> type
which is just a marker interface. It will never be instantiated, instead
by delegating property to <code>Node&lt;Payment&gt;</code>, the conversion
<code>Cursor&lt;Transacton, F&gt; =&gt; Cursor&lt;Payment, F&gt;</code> will be made.</p>
<div class="formalpara-title"><p><strong>how Node is defined</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-type">out T</span>&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;Op&gt;</span> <span class="hljs-title">getValue</span><span class="hljs-params">(ref: <span class="hljs-type">Cursor</span>&lt;*, Op&gt;, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Cursor&lt;T, Op&gt; {
    <span class="hljs-keyword">return</span> Cursor(ref.f.narrow(property.name))
  }
}
</code></pre>
<p>Inside <code>Node</code>, a new Cursor is created with the focus narrowing down
using a property name. Using this technique, by just calling extension
properties a focus can narrow down to the last node where the last node
is delegated to <code>Leaf</code> instead of <code>Node</code>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span>
<span class="hljs-keyword">val</span> &lt;F&gt; Cursor&lt;Person, F&gt;.name <span class="hljs-keyword">by</span> Leaf&lt;String&gt;()
</code></pre>
<p><code>Leaf&lt;V&gt;</code> is defined in the same way as Node except for the return value
of <code>getValue</code>.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">open</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Leaf</span>&lt;<span class="hljs-type">out V</span>&gt; {
  <span class="hljs-keyword">open</span> <span class="hljs-keyword">operator</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;Op&gt;</span> <span class="hljs-title">getValue</span><span class="hljs-params">(ref: <span class="hljs-type">Cursor</span>&lt;*, Op&gt;, property: <span class="hljs-type">KProperty</span>&lt;*&gt;)</span></span>: Cursor&lt;Leaf&lt;V&gt;, Op&gt; {
    <span class="hljs-keyword">return</span> Cursor(ref.f.narrow(property.name))
  }
}
</code></pre>
<p>Leaf is needed to define an extension property that allows reading a
value from that node. The property has the following signature
<code>val &lt;V, T&gt; Cursor&lt;Leaf&lt;V&gt;, Read&lt;T&gt;&gt;.value: V</code> which says: given the
cursor focused on a leaf and parametrised over a read operation, provide
a value contained by the leaf.</p>
<p><img src="/images/fantastic/domain_red.png" alt=""/></p>
<p>The remaining logic is described below</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// the main data structure where T type - is the root type</span>
<span class="hljs-comment">// in our case, T is Transaction.</span>
<span class="hljs-comment">// root is just an empty persisntent map</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Domain</span>&lt;<span class="hljs-type">out T</span>&gt;(<span class="hljs-keyword">val</span> root: PMap = PHashMap.EMPTY)

<span class="hljs-comment">// The read operation that focus owns (Op)</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">Read</span>&lt;<span class="hljs-type">out M</span>&gt; {
  <span class="hljs-keyword">val</span> path: Path         <span class="hljs-comment">// path to the current node (ex. [&quot;payment&quot;, &quot;currency&quot;])</span>
  <span class="hljs-keyword">val</span> domain: Domain&lt;M&gt;  <span class="hljs-comment">// the reference to the root</span>
}

<span class="hljs-comment">// the implementation of the focus</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span>&lt;<span class="hljs-type">out T</span>&gt;(<span class="hljs-keyword">val</span> p: Path, <span class="hljs-keyword">val</span> dm: Domain&lt;T&gt;) : Focus&lt;Read&lt;T&gt;&gt; {
  <span class="hljs-comment">// this is how narrowing happens, just extend the path and keep the refernce to the root</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">narrow</span><span class="hljs-params">(k: <span class="hljs-type">String</span>)</span></span>: Focus&lt;Read&lt;T&gt;&gt; = Reader(p.append(k), dm)

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> op: Read&lt;T&gt; = <span class="hljs-keyword">object</span> : Read&lt;T&gt; {
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> domain: Domain&lt;T&gt; = dm
    <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> path: Path = p
  }
}

<span class="hljs-comment">// take a focus, take a read operation from it and ask for value</span>
<span class="hljs-comment">// by traversing the root using path</span>
<span class="hljs-keyword">val</span> &lt;V, T&gt; Cursor&lt;Leaf&lt;V&gt;, Read&lt;T&gt;&gt;.value: V
  <span class="hljs-keyword">get</span>() = f.op.path.getIn(f.op.domain.root) <span class="hljs-keyword">as</span> V

<span class="hljs-comment">// this is how cursor get&#x27;s created, emtpy path and reference to the root</span>
<span class="hljs-keyword">val</span> &lt;T&gt; Domain&lt;T&gt;.cursor: Cursor&lt;T, Read&lt;T&gt;&gt;
  <span class="hljs-keyword">get</span>() = Cursor(Reader(Path.EMPTY, <span class="hljs-keyword">this</span>))
</code></pre>
<h4 id="update"><a class="anchor" href="#update"><span class="icon icon-link"></span></a>Update</h4>
<p>So far we can traverse the data structure and read values from it. The
next step is to learn how to update it. Problems start when we realise
that the underlying data structure is persistent and there is no way to
mutate it. To emulate mutation, a special wrapper has to be defined. It
reassigns the reference after each mutation.</p>
<div class="formalpara-title"><p><strong>immutable ⇒ mutable</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mutable</span>(<span class="hljs-keyword">var</span> m: PMap) {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">write</span><span class="hljs-params">(p: <span class="hljs-type">Path</span>, a: <span class="hljs-type">Any</span>?)</span></span> {
    m = p.assocIn(m, a)
  }

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">read</span><span class="hljs-params">(p: <span class="hljs-type">Path</span>)</span></span> = p.getIn(m)
}
</code></pre>
<p>Then, we’ll need to implement the <code>Write</code> operation which supports
reading and writing under a specific path. At first glance, <code>read</code>
operation is unnecessary, but it’s needed to read the final result after
all modification were applied using an empty path. Another application
of the <code>read()</code> operation is node initialisation. E.g. if you create an
empty domain and decide to write a value to leaf using a cursor, all the
parent nodes need to be initialised first.</p>
<div class="formalpara-title"><p><strong>Op for <code>Cursor&lt;T, Write&gt;</code></strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Write</span> {
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>: Any?
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">write</span><span class="hljs-params">(a: <span class="hljs-type">Any</span>?)</span></span>
}
</code></pre>
<p>And the corresponding cursor</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WriterCursor</span>(<span class="hljs-keyword">val</span> m: Mutable, <span class="hljs-keyword">val</span> path: Path) : Focus&lt;Write&gt; {
  <span class="hljs-comment">// exactly the same narrowing pattern</span>
  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">narrow</span><span class="hljs-params">(k: <span class="hljs-type">String</span>)</span></span>: Focus&lt;Write&gt; = WriterCursor(m, path.append(k))

  <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> op: Write = <span class="hljs-keyword">object</span> : Write {
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">write</span><span class="hljs-params">(a: <span class="hljs-type">Any</span>?)</span></span> = m.write(path, a)
    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span>: Any? = m.read(path)
  }
}
</code></pre>
<p>And at some point in time, we might want to switch from the <code>Read</code>
cursor to the <code>Write</code> cursor. For that, a special function exists.</p>
<div class="formalpara-title"><p><strong>Cursor&lt;T, Read&gt; ⇒ Cursor&lt;T, Write&gt;</strong></p></div>
<pre><code class="hljs language-kotlin"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T, M&gt;</span> Cursor<span class="hljs-type">&lt;M, Read&lt;T&gt;</span>&gt;.<span class="hljs-title">update</span><span class="hljs-params">(update: <span class="hljs-type">Cursor</span>&lt;<span class="hljs-type">M</span>, Write&gt;.()</span></span> -&gt; <span class="hljs-built_in">Unit</span>): Domain&lt;T&gt; {
  <span class="hljs-comment">// take a root, make a mutable from it</span>
  <span class="hljs-keyword">val</span> m = Mutable(f.op.domain.root)
  <span class="hljs-comment">// create a writer from mutable and apply `update` supplied from outside</span>
  <span class="hljs-comment">// exactly the same pattern as any other DSL has</span>
  Cursor&lt;M, Write&gt;(WriterCursor(m, f.op.path)).update()
  <span class="hljs-comment">// read the final value from the root and return a new instance of Domain</span>
  <span class="hljs-keyword">return</span> Domain(m.read(Path.EMPTY) <span class="hljs-keyword">as</span> PMap)
}

<span class="hljs-comment">// to simplify the initialisation</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;M&gt;</span> <span class="hljs-title">domain</span><span class="hljs-params">(f: <span class="hljs-type">Cursor</span>&lt;<span class="hljs-type">M</span>, Write&gt;.()</span></span> -&gt; <span class="hljs-built_in">Unit</span>) = Domain&lt;M&gt;().cursor.update(f)
</code></pre>
<p>And finally, a set of public typed operation that API consumers use</p>
<pre><code class="hljs language-kotlin"><span class="hljs-comment">// for each leaf initial value is null</span>
<span class="hljs-comment">// for each node initial value is empty persistent map</span>
<span class="hljs-function"><span class="hljs-keyword">fun</span> Write.<span class="hljs-title">init</span><span class="hljs-params">(k: <span class="hljs-type">KClass</span>&lt;*&gt;)</span></span> {
  <span class="hljs-keyword">if</span> (read() == <span class="hljs-literal">null</span>) {
    write(<span class="hljs-keyword">when</span> (k) {
      Leaf::<span class="hljs-keyword">class</span> -&gt; <span class="hljs-literal">null</span>
      <span class="hljs-keyword">else</span> -&gt; PArrayMap.EMPTY
    })
  }
}

<span class="hljs-keyword">operator</span> <span class="hljs-keyword">inline</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;<span class="hljs-keyword">reified</span> T&gt;</span> Cursor<span class="hljs-type">&lt;T, Write&gt;</span>.<span class="hljs-title">invoke</span><span class="hljs-params">(
    updateFn: <span class="hljs-type">Cursor</span>&lt;<span class="hljs-type">T</span>, Write&gt;.()</span></span> -&gt; <span class="hljs-built_in">Unit</span>): <span class="hljs-built_in">Unit</span> {
  <span class="hljs-comment">// init the current node (it might be null if we haven&#x27;t visited it before)</span>
  f.op.<span class="hljs-keyword">init</span>(T::<span class="hljs-keyword">class</span>)
  updateFn()
}

<span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-type">&lt;T&gt;</span> Cursor<span class="hljs-type">&lt;Leaf&lt;T&gt;</span>, Write&gt;.<span class="hljs-title">set</span><span class="hljs-params">(t: <span class="hljs-type">T</span>)</span></span>: <span class="hljs-built_in">Unit</span> {
  <span class="hljs-comment">// just delegate to write</span>
  f.op.write(t)
}
</code></pre>
<p>The <code>invoke</code> function is responsible for Node initialisation whereas
<code>set</code> sets the Leaf’s value</p>
<pre><code class="hljs language-kotlin">domain&lt;Transaction&gt; {
  (payment) {  <span class="hljs-comment">// &lt;- here invoke is called</span>
    currency.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;AUD&quot;</span>)
    amount.<span class="hljs-keyword">set</span>(<span class="hljs-number">15</span>)
  }
}

<span class="hljs-comment">// ↑ is equal to the desugarised version ↓</span>
domain&lt;Transaction&gt; {
  payment.invoke({
    currency.<span class="hljs-keyword">set</span>(<span class="hljs-string">&quot;AUD&quot;</span>)
    amount.<span class="hljs-keyword">set</span>(<span class="hljs-number">15</span>)
  })
}
</code></pre>
<p>And at the end, a Path that does all the work, but in fact, it does
nothing except for delegating functionality to functions from Clojure
that do all the work on untyped persistent data structures.</p>
<pre><code class="hljs language-kotlin"><span class="hljs-keyword">import</span> clojure.`core$assoc_in` <span class="hljs-keyword">as</span> assocIn
<span class="hljs-keyword">import</span> clojure.`core$get_in` <span class="hljs-keyword">as</span> getIn
<span class="hljs-keyword">import</span> clojure.lang.*

<span class="hljs-keyword">data</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Path</span>(<span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> v: APersistentVector) {
  <span class="hljs-keyword">companion</span> <span class="hljs-keyword">object</span> {
    <span class="hljs-keyword">val</span> EMPTY = Path(PersistentVector.EMPTY)
  }

  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">append</span><span class="hljs-params">(a: <span class="hljs-type">String</span>)</span></span>: Path = Path(v.cons(a) <span class="hljs-keyword">as</span> APersistentVector)
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">getIn</span><span class="hljs-params">(model: <span class="hljs-type">Any</span>?)</span></span>: Any? = getIn.invokeStatic(model, v)
  <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">assocIn</span><span class="hljs-params">(m: <span class="hljs-type">Any</span>?, a: <span class="hljs-type">Any</span>?)</span></span>: Any? = assocIn.invokeStatic(m, v, a)
}
</code></pre>
<p>Using these primitives, we built a really powerful type safe DSL to work
on immutable data structures. Yes, it has a few downsides. E.g. data
classes solution has better performance. And most of the time it’s
concise enough, unless you have a really deeply nested tree. In that
case, you might also try to use <a href="https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing">the lenses
pattern</a>
which comes from the functional world and solves the same problem. But
if you already have untyped data structures in your project and have to
work with them, Kotlin provides a truly unique set of features that
allows you to build a powerful DSL to make your life safer and easier.</p>
<p>It’s very probable that some parts of the solution shown above might
still be unclear, in that case, I encourage you to clone <a href="https://github.com/SerCeMan/talk-fantastic-dsls-example">the code
example</a> in
your IDE, run it and try to play with types. It will help a lot and can
give you some interesting ideas on how advanced Kotlin features can be
used.</p>
<h2 id="conclusions"><a class="anchor" href="#conclusions"><span class="icon icon-link"></span></a>Conclusions</h2>
<ul>
<li>
<p>Kotlin provides many unique features to build DSLs easily</p>
</li>
<li>
<p>DSLs in Kotlin work best as configuration APIs</p>
</li>
<li>
<p>They can be a powerful abstraction over untyped data structures</p>
</li>
</ul>
<h3 id="warnings"><a class="anchor" href="#warnings"><span class="icon icon-link"></span></a>Warnings</h3>
<ul>
<li>
<p>Most of the time plain code is better than DSL
There is no point in building DSL &quot;just because I can&quot;, plain Kotlin
code is often much easier to read and understand.</p>
</li>
<li>
<p>Provide a way to extend and bypass your DSL
If you publish DSL as a part of your API, it’s always a good idea to
give a way to bypass or extend it. Of course, if it’s a Gradle-like
DSL then you can cover everything. But in the case of a html DSL, a
user might want to introduce some tags that your DSL doesn’t support.
Or, he can have an already rendered string which needs to be inserted
somewhere.</p>
</li>
</ul>
<h2 id="links"><a class="anchor" href="#links"><span class="icon icon-link"></span></a>Links</h2>
<ul>
<li>
<p><a href="https://github.com/SerCeMan/talk-fantastic-dsls-example">Cursor DSL source
code</a></p>
</li>
<li>
<p>Why you should use DSLs: <a href="http://jonnyzzz.com/blog/2016/09/02/dsl-building/">Building DSL Instead of an IDE
Plugin</a></p>
</li>
<li>
<p>Why you shouldn’t: <a href="https://victor.kropp.name/blog/kotlin-dsls-good-bad-and-ugly/">DSLs in Kotlin: The Good, the Bad and the
Ugly</a></p>
</li>
</ul>
<h2 id="thanks"><a class="anchor" href="#thanks"><span class="icon icon-link"></span></a>Thanks</h2>
<ul>
<li>
<p>Kotlin team for creating an awesome language!
Please, press a ★ button on the <a href="https://github.com/JetBrains/kotlin">Kotlin’s GitHub
repo</a> if you haven’t done it yet.</p>
</li>
<li>
<p><a href="https://twitter.com/jetzajac">@JetZajac</a> who initially came up with
the idea of persistent data structure based DSLs</p>
</li>
<li>
<p>You for reading it</p>
</li>
</ul>
<h2 id="share-this-article"><a class="anchor" href="#share-this-article"><span class="icon icon-link"></span></a>Share this article</h2>
<ul>
<li><a href="https://twitter.com/SerCeMan/status/880365305314254848">Twitter</a></li>
<li><a href="https://news.ycombinator.com/item?id=14663115">Hacker News</a></li>
</ul></div></article></div></main></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"source":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    p: \"p\",\n    img: \"img\",\n    h2: \"h2\",\n    a: \"a\",\n    span: \"span\",\n    blockquote: \"blockquote\",\n    code: \"code\",\n    strong: \"strong\",\n    pre: \"pre\",\n    h3: \"h3\",\n    ul: \"ul\",\n    li: \"li\",\n    h4: \"h4\"\n  }, _provideComponents(), props.components), {Quote} = _components;\n  if (!Quote) _missingMdxReference(\"Quote\", true);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.p, {\n      children: \"Hi!\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Kotlin is a very rich language. Unlike many other languages, it allows\\ndevelopers to create another language inside it. For example, to mimic\\nHTML syntax or to build a completely typed SQL query. But Kotlin’s power\\nisn’t limited to simple DSLs. With some Kotlin-fu, it’s possible to\\nwrite a DSL that allows manipulating untyped data structures in a typed\\nmanner. In this article, we’ll go through different ways to define DSL\\nin Kotlin, from very simple to fantastically powerful.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/kotlin_island.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(Quote, {\n      quote: \"Peter the Great at one time even considered moving the capital of\\nRussia to Kotlin Island, proof of the sovereign’s great affinity with\\nwater. This utopian idea failed, but many of the fantasies of this\\nbaroque autocrat still managed to become implemented.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"warning\",\n      children: _jsx(_components.p, {\n        children: \"Some parts of this article might be hard to understand without knowledge\\nof Kotlin syntax. I tried to explain every feature I showed, but the\\ngeneral ability to speak Kotlin is strongly suggested.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So, let’s begin the journey.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"what-is-s-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#what-is-s-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"What is s DSL\"]\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"Domain-specific language (noun): a computer programming language of\\nlimited expressiveness focused on a particular domain\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"—  Martin Fowler Domain-Specific Languages\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Here though, I prefer to give DSLs a slightly different definition which\\nreflects what is written in the article\"\n    }), \"\\n\", _jsxs(_components.blockquote, {\n      children: [\"\\n\", _jsx(_components.p, {\n        children: \"a language (or a set of abstractions) that’s built to deal with a\\nspecific domain\"\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The main difference is that a DSL might not only be a separate language\\nbut also a subset of a language which is used to work on a specific\\ndomain. This kind of DSL can even be built in Java with some fluent API,\\nbut very often it’s indistinguishable from a plain good code. To\\ncontrast in Kotlin, many remarkable features might make an internal DSL\\nlook different.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"calling-convention\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#calling-convention\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Calling convention\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The first feature actively used by DSLs in Kotlin is a special calling\\nconvention. If the last parameter of a method is a function, and you’re\\npassing a lambda expression there, you can specify it outside of\\nparentheses.\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"For example, if one wants to create a function \", _jsx(_components.code, {\n        children: \"dotimes\"\n      }), \" that takes a\\nnumber \", _jsx(_components.code, {\n        children: \"n\"\n      }), \", a function \", _jsx(_components.code, {\n        children: \"f\"\n      }), \" and applies it, the easiest way to do that is\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"good old dotimes\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"dotimes\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(n: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Int\"\n            }), \", f: () -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (i \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".n-\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n        f()\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"dotimes\"\n      }), \" can be called in this way\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"dotimes(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", {\\n    println(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, Kotlin!\\\"\"\n        }), \")\\n})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Or, using the lambda parameter convention and placing lambda function\\noutside parentheses.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"dotimes(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \") {\\n    println(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, Kotlin!\\\"\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Moreover, the parentheses can be omitted completely if a lambda is the\\nonly parameter of a function. E.g. \", _jsx(_components.code, {\n        children: \"do5times\"\n      }), \" function that only takes a\\nlambda as a parameter can be defined and called as\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"do5times\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(f: () -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = dotimes(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"5\"\n        }), \", f)\\n\\ndo5times {\\n    println(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hello, Kotlin!\\\"\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But despite being important, that calling convention is just a tiny\\ncontribution to DSLs when compared to extension functions.\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"extension-functions\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#extension-functions\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Extension functions\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extension functions simply allow you to extend the functionality of a\\nclass from the outside.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Simple extension function\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" String.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"removeSpaces\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": String {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \".filter({ c -\u003e c != \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"' '\"\n        }), \" })\\n}\\n\\nprint(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Hi ! , ext\\\"\"\n        }), \".removeSpaces()) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Hi!,ext\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, the \", _jsx(_components.code, {\n        children: \"removeSpace\"\n      }), \" function is defined on the class String which\\nenables an ability to call \", _jsx(_components.code, {\n        children: \"removeSpaces\"\n      }), \" on any \", _jsx(_components.code, {\n        children: \"String\"\n      }), \" instance.\\nUnsurprisingly, it removes all the spaces from it. Inside the functions,\\n\", _jsx(_components.code, {\n        children: \"this\"\n      }), \" refers to the instance of a receiver class and can be omitted\\nlike you do when you’re writing a member function. That might sound\\ncomplicated if you have never heard about extension functions before,\\nbut looking at the result of the compilation might make it much easier\\nto understand.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Decompiled java code\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"static\"\n        }), \" String \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"removeSpaces\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(String $receiver)\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"StringBuilder\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"sb\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"StringBuilder\"\n        }), \"();\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"int\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"i\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"; i \u003c $receiver.length(); i++) {\\n    \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"char\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-variable\",\n          children: \"c\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-operator\",\n          children: \"=\"\n        }), \" $receiver.charAt(i);\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (c != \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"' '\"\n        }), \") {\\n      sb.append(c);\\n    }\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" sb.toString();\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Extension functions are not some kind of magic. It’s not a Groovy-like\\nmonkey patching, they get compiled to simple static functions. But that\\nexample shows us a very important caveat - extension functions are\\nresolved statically because there is no dispatch mechanism for static\\nmethods\"\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Even though this snippet is very simple, it can raise another question -\\n\\\"where did the \", _jsx(_components.code, {\n        children: \"StringBuilder\"\n      }), \" came from?\\\". An close look at the first\\nsnippet through \", _jsx(_components.code, {\n        children: \"Java\"\n      }), \" glasses gives the answer - there is no function\\ncalled \", _jsx(_components.code, {\n        children: \"filter\"\n      }), \" defined in the class String. \", _jsx(_components.code, {\n        children: \"filter\"\n      }), \" is also an\\nextension function defined in the Kotlin standard library.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"filter function from kotlin stdlib\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"inline\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" String.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"filter\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(predicate: (\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Char\"\n            }), \") -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Boolean\"\n            }), \")\"]\n          })]\n        }), \": String {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" destination = StringBuilder()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (index \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0.\"\n        }), \".length - \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \") {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" element = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"(index)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (predicate(element))\\n      destination.append(element)\\n  }\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" destination.toString()\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Kotlin defines a lot of extension functions for Java classes in the\\nstandard library. That’s why Kotlin is so convenient to use. One might\\nnotice that the function has an \", _jsx(_components.code, {\n        children: \"inline\"\n      }), \" modifier on it which explains\\nwhy decompiled \", _jsx(_components.code, {\n        children: \"removeSpaces\"\n      }), \" has a \", _jsx(_components.code, {\n        children: \"StringBuilder\"\n      }), \" inside and not a\\ncall to \", _jsx(_components.code, {\n        children: \"filter\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Many newcomers to Kotlin use the \", _jsx(_components.code, {\n        children: \"inline\"\n      }), \" modifier everywhere under the\\nimpression that inlining can improve performance. It can, but in many\\ncases, inline functions don’t improve performance at all, they even can\\nmake it worse. There is an inspection for that in IntelliJ IDEA.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/inspection.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"There are also some other uses for \", _jsx(_components.code, {\n        children: \"inline\"\n      }), \" which can be found in\\n\", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/inline-functions.html\",\n        children: \"docs\"\n      }), \".\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"extension-function-on-generic-type\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#extension-function-on-generic-type\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Extension function on generic type\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The Kotlin compiler is smart enough to allow for the definition of\\nextension functions on a certain generic type. In this example,\\n\", _jsx(_components.code, {\n        children: \"toIntArray\"\n      }), \" function can be called only on a collection that contains\\nintegers. This makes extension functions truly unique, there is no way\\n(without subclassing) to define a method for \", _jsx(_components.code, {\n        children: \"Collection\"\n      }), \" class that can\\nbe called only on an \", _jsx(_components.code, {\n        children: \"Int\"\n      }), \" collection.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" Collection\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cInt\u003e\"\n          }), \".\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"toIntArray\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": IntArray {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result = IntArray(size)\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" index = \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (element \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \")\\n    result[index++] = element\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" result\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"listOf(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"2\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"3\"\n        }), \").toIntArray()       \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// works\"\n        }), \"\\nlistOf(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"1\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"2\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"3\\\"\"\n        }), \").toIntArray() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// type error\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"If Kotlin has become your native language, you might be wondering now,\\nwhy I’m talking about these simple features in an article about DSLs.\\nThe thing is, the majority of Kotlin DSLs are based on the\\nexpressiveness of the two features mentioned above.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"first-simple-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#first-simple-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"First simple DSL\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Given the aforementioned features, it’s very easy to write a first very\\nsimple DSL.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s say we need to write an event-based droid fighting platform so\\nthat users can provide their own strategies and register them on the\\nplatform. For each event the user is interested in, they must provide a\\ncallback with the droid’s behaviour. A droid has an interface with a few\\nmethods for defeating other droids. Or, humans if you will.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"the droid\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Droid\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" peopleAround: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Boolean\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" gun: Gun\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"fire\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(gun: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Gun\"\n            }), \")\"]\n          })]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"moveLeft\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"moveRight\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This sounds like an ideal case for DSL and now we need to define a\\npublic API which the clients will be happy to use. To provide the\\ndroid’s behaviour we’ll write a public function.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"API\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" droid: Droid = getDroid() \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// inaccessible from the public API\"\n        }), \"\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"on\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(cmd: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \", f: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Droid\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n  droid.f()\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The type of the argument \", _jsx(_components.code, {\n        children: \"f\"\n      }), \" might look weird, but it’s just the type of\\n0-arity extension function on the type Droid. And finally, the APIs\\nconsumers can register events in the platform.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"strategy example\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"on(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"back\\\"\"\n        }), \") {\\n  moveLeft()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (peopleAround) {\\n    fire(gun)\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, the anonymous extension function is a second parameter and\\ntherefore can be written outside parentheses. \", _jsx(_components.code, {\n        children: \"this\"\n      }), \" in the function has\\na type \", _jsx(_components.code, {\n        children: \"Droid\"\n      }), \" and therefore \", _jsx(_components.code, {\n        children: \"moveLeft()\"\n      }), \" as well as other functions and\\nproperties can be called by themselves without providing an explicit\\nreceiver type..\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The strategy looks very natural, it clearly says that if our droid\\nreceives a \", _jsx(_components.code, {\n        children: \"back\"\n      }), \" command, it should move left and try to shoot some\\nfolks around him. The next snippet shows to what it can be compiled to\\nin order to make it even clearer for those who don’t speak kotlin well\\nyet.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"decompiled java call\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-java\",\n        children: [\"on(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"back\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"new\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Function1\"\n        }), \"\u003cDroid, Unit\u003e() {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"public\"\n        }), \" Unit \", _jsx(_components.span, {\n          className: \"hljs-title function_\",\n          children: \"invoke\"\n        }), _jsx(_components.span, {\n          className: \"hljs-params\",\n          children: \"(Droid droid)\"\n        }), \" {\\n    droid.moveLeft();\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (droid.getPeopleAround()) {\\n      droid.fire(droid.getGun());\\n    }\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Unit.INSTANCE;\\n  }\\n});\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"html-builders\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#html-builders\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"HTML builders\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Building DSLs using extension functions isn’t limited to simple droid\\nfighting strategies. For example, it allows us to build a completely\\ntyped HTML syntax; HTML builders are even mentioned in the \", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/type-safe-builders.html\",\n        children: \"official\\ndocumentation\"\n      }), \".\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"html builders\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" list = listOf(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Kotlin\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"is\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"awesome\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" result: HTML =\\n  html {\\n    head {\\n      title { +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"HTML DSL in Kotlin\\\"\"\n        }), \" }\\n    }\\n    body {\\n      p {\\n        +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a line about Kotlin\\\"\"\n        }), \"\\n      }\\n      a(href = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"jetbrains.com/kotlin\\\"\"\n        }), \") {\\n        +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Kotlin\\\"\"\n        }), \"\\n      }\\n      p {\\n        +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Kotlin is:\\\"\"\n        }), \"\\n        ul {\\n          \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (arg \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" list)\\n            li { +arg }\\n        }\\n      }\\n    }\\n  }\\nprintln(result)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And these type-safe builders aren’t a Kotlin invention, on the JVM land\\nthey were originated in Groovy. But Groovy is a dynamic language,\\nbuilders there are not type-safe.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"important\",\n      children: _jsx(_components.p, {\n        children: \"It wouldn’t be completely fair to say that even though it’s what\\nKotlin’s documentation says, Groovy supports static compilation\\noptionally and there are some ways to compile builders statically as\\nwell.\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The implementation of a DSL in dynamically typed languages is often very\\ndifferent to statically typed languages. In Kotlin, in order to build a\\nDSL, you need to describe the whole schema of the future language. And\\ngiven that the result is a deeply nested data structure, the easiest way\\nto convert it to string is to traverse the whole data-structure\\nrecursively.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"base interface\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Element\"\n        }), \" {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"render\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(builder: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"StringBuilder\"\n            }), \", indent: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The simplest line of text can be represented as\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"TextElement\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" text: String) : Element {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"render\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(builder: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"StringBuilder\"\n            }), \", indent: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \" {\\n    builder.append(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$indent\"\n          }), _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$text\"\n          }), \"\\\\n\\\"\"]\n        }), \")\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The real tag representation is a bit more complex\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"abstract\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" name: String) : Element {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" children = arrayListOf\u003cElement\u003e()\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" attributes = hashMapOf\u003cString, String\u003e()\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// open tag\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// render attributes\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// render children recursively\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// close tag\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"render\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(builder: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"StringBuilder\"\n            }), \", indent: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \" {\\n    builder.append(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$indent\"\n          }), \"\u003c\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$name\"\n          }), _jsx(_components.span, {\n            className: \"hljs-subst\",\n            children: \"${renderAttributes()}\"\n          }), \"\u003e\\\\n\\\"\"]\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"for\"\n        }), \" (c \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"in\"\n        }), \" children) {\\n      c.render(builder, indent + \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"  \\\"\"\n        }), \")\\n    }\\n    builder.append(\", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$indent\"\n          }), \"\u003c/\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$name\"\n          }), \"\u003e\\\\n\\\"\"]\n        }), \")\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"renderAttributes\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \" = attributes.map { (k, v) -\u003e \", _jsxs(_components.span, {\n          className: \"hljs-string\",\n          children: [\"\\\" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$k\"\n          }), \"=\\\\\\\"\", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"$v\"\n          }), \"\\\\\\\"\\\"\"]\n        }), \" }.joinToString(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \")\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"protected\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cT : Element\u003e\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"initTag\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(tag: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n    tag.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \"()\\n    children.add(tag)\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" String.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"unaryPlus\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \" {\\n    children.add(TextElement(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \"))\\n  }\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"toString\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": String {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" builder = StringBuilder()\\n    render(builder, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \")\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" builder.toString()\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It contains a representation of attributes and a set of children. But\\nthe main part that requires attention is the \", _jsx(_components.code, {\n        children: \"initTag\"\n      }), \" function which\\nlooks very similar to the function \", _jsx(_components.code, {\n        children: \"on\"\n      }), \" from the \\\"robot fighting\\\" DSL\\ndefinition.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Another interesting part is an extension function \", _jsx(_components.code, {\n        children: \"unaryPlus\"\n      }), \" defined as\\nan operator for class String inside the \", _jsx(_components.code, {\n        children: \"Tag\"\n      }), \". It allows us to use a\\nconvenient (but let’s be honest not obvious at all) way to insert a line\\nof text inside code like:\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"¯\\\\_(ツ)_/¯ unary plus to append a line of text\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"body {\\n  +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"just a random line\\\"\"\n        }), \"\\n  +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"another line\\\"\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And the rest of the DSL is an enumeration of all possible tags.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"\u003chead\u003e,\u003ctitle\u003e,\u003cbody\u003e,\u003ca\u003e,\u003cul\u003e,\u003cli\u003e,\u003cp\u003e\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"HTML\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"html\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"head\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Head\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Head(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"body\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Body\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Body(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Head\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"head\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"title\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Title\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Title(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Title\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"title\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"abstract\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"BodyTag\"\n        }), \"(name: String) : Tag(name) {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"p\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"P\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(P(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"ul\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"UL\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(UL(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"a\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(href: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \", \", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"A\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" a = A()\\n    initTag(a, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n    a.href = href\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Body\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"body\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"UL\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"ul\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"li\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"LI\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(LI(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"LI\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"li\\\"\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"P\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"p\\\"\"\n        }), \")\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"A\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"BodyTag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"a\\\"\"\n        }), \") {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" href: String\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"() = attributes[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"href\\\"\"\n        }), \"] ?: \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"\\\"\"\n        }), \"\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(value) {\\n      attributes[\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"href\\\"\"\n        }), \"] = value\\n    }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"As you can see, all these classes define a possible hierarchy of calls.\\nThis DSL is just a toy DSL, and therefore it covers a very small and\\nlimited subset of HTML. It is extremely tedious to write the whole HTML\\nDSL manually. The actual \", _jsx(_components.a, {\n        href: \"https://github.com/Kotlin/kotlinx.html\",\n        children: \"HTML DSL\\nimplementation\"\n      }), \" uses a real \", _jsx(_components.a, {\n        href: \"https://github.com/Kotlin/kotlinx.html/blob/master/generate/src/main/resources/html_5.xsd\",\n        children: \"XSD\\nschema\"\n      }), \"\\nto generate all possible classes for the DSL.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"there-is-always-a-problem\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#there-is-always-a-problem\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"There is always a problem\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This could already be awesome, but the example demonstrates a very weird\\nbehaviour — nobody stops you from defining tags inside each other\\nmultiple times.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"the problem\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"head {\\n  head {\\n    head {\\n      \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// stil possible to write head because implicit receiver html is available\"\n        }), \"\\n    }\\n  }\\n  title { +\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"XML encoding with Kotlin\\\"\"\n        }), \" }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Prior to Kotlin 1.1, the only solution was to redefine function with\\ndeprecation.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Head\"\n        }), \" : \", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"head\\\"\"\n        }), \") {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-meta\",\n          children: [\"@Deprecated(message = \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"wrong scope\\\"\"\n          }), \", level = DeprecationLevel.ERROR)\"]\n        }), \"\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"head\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Head\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Head(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"title\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"init\"\n            }), \": \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Title\"\n            }), \".() -\u003e \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Unit\"\n            }), \")\"]\n          })]\n        }), \" = initTag(Title(), \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \")\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/err1.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The problem with this approach is that it requires an incredible amount\\nof boilerplate and a full understanding of all possible combinations. In\\n1.1,\\n\", _jsx(_components.a, {\n        href: \"https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md\",\n        children: \"KEEP-57\"\n      }), \"\\nintroduced an alternative to that approach: the \", _jsx(_components.code, {\n        children: \"@DslMarker\"\n      }), \" annotation\\nwas introduced which allows us to define a \", _jsx(_components.code, {\n        children: \"DSL marker\"\n      }), \" and introduces a\\nset of rules for classes annotated with that marker:\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"an implicit receiver may belong to a DSL if marked with a\\ncorresponding DSL marker annotation\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"two implicit receivers of the same DSL are not accessible in the same\\nscope\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"the closest one wins\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"other available receivers are resolved as usual, but if the resulting\\nresolved call binds to such a receiver, it’s a compilation error\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"So, the HTML DSL can be fixed by introducing a \", _jsx(_components.code, {\n        children: \"@HtmlTagMarker\"\n      }), \" DSL\\nmarker and annotating \", _jsx(_components.code, {\n        children: \"Tag\"\n      }), \" with it.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-meta\",\n          children: \"@HtmlTagMarker\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"abstract\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Tag\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" name: String) : Element {\\n \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/err2.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"DSLs that give us an ability to construct nested data structures such as\\nHTML builders, different configurations, UI builders, etc. is where\\nKotlin really shines. Kotlin took an awesome idea from Groovy and made\\nit safe and easy to use.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"There are a few more examples of DSLs of that kind:\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://blog.jetbrains.com/teamcity/2016/11/kotlin-configuration-scripts-an-introduction/\",\n            children: \"TeamCity\\nDSL\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://github.com/gradle/gradle-script-kotlin\",\n            children: \"Gradle with Kotlin\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://github.com/gradle/gradle-script-kotlin\",\n            children: \"Anko\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"http://spekframework.org\",\n            children: \"Spek framework\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But unsurprisingly, it’s not the only type of DSL that can be\\nimplemented in Kotlin…\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"fantastic-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#fantastic-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Fantastic DSL\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Not all domains are born the same. Let’s consider a completely different\\ndomain. A system which handles transactions containing a payment in some\\ncurrency and two people - a sender and a receiver.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain.svg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The transaction structure has to be immutable to make it safer. But\\nsometimes, we might need to create a new transaction with an updated\\nfield. For example, the name of the receiver (from) person might need to\\nbe changed to let’s say \\\"John\\\". There are a few ways to implement that\\nin Kotlin\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"data-classes\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#data-classes\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Data classes\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Let’s start with an idiomatic Kotlin way. The class hierarchy can be\\nconcisely represented as\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"data\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Transaction\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" payment: Payment, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" parts: Parts)\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Payment\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" currency: String, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" amount: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \")\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Parts\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" from: Person, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" to: Person)\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" id: \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" name: String)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"An instance of the \", _jsx(_components.code, {\n        children: \"Transaction\"\n      }), \" can easily be created as well\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"create\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trs = Transaction(\\n  Payment(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"),\\n  Parts(\\n    Person(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \"),\\n    Person(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \")\\n  )\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But problems start when we need to update this nested data structure.\\nGenerally, there two ways to do that. The first option is to completely\\nrecreate the transaction which doesn’t look good.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update [1]\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans = Transaction(trs.payment, Parts(\\n  Person(trs.parts.from.id, \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"),\\n  trs.parts.to)\\n)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Another is to use\\n\", _jsx(_components.a, {\n        href: \"https://kotlinlang.org/docs/reference/data-classes.html#copying\",\n        children: \"copy\"\n      })]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update [2]\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stansTrs2 = trs.copy(\\n  parts = trs.parts.copy(\\n    from = trs.parts.from.copy(\\n      name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"\\n    )\\n  )\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And the copy version doesn’t look good either. Even though it’s\\ntolerable now, the bigger the data structure, the uglier the code look\\nlike. On a deeply nested immutable data structure, it looks like a\\ntriangle instead of a simple call chain from the mutable world.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"ohhhh\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" stansTrs2 = trs.copy(\\n  parts = trs.parts.copy(\\n    from = trs.parts.from.copy(\\n      person = trs.parts.from.person.copy(\\n        parts = trs.parts.from.person.parts.copy(\\n          from = trs.parts.from.person.parts.from.copy(\\n            person = trs.parts.from.person.parts.from.person.copy(\\n              parts = trs.parts.from.person.parts.from.person.parts.copy(\\n                from = trs.parts.from.person.parts.from.person.parts.from.copy(\\n                  person = trs.parts.from.person.parts.from.person.parts.from.person.copy(\\n                    parts = trs.parts.from.person.parts.from.person.parts.from.person.parts.copy(\\n                      from = trs.parts.from.person.parts.from.person.parts.from.person.parts.from.copy(\\n                        name = \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"jonh\\\"\"\n        }), \"\\n                      ))))))))))))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Don’t get me wrong, I like parentheses. It feels like a lisp (which I\\nlike a lot), but what no one likes is the wall of boilerplate above.\"\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"persistent-data-structures\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#persistent-data-structures\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Persistent Data Structures\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"But talking about lisps, there is another awesome language called\\nClojure. It’s a lisp running on JVM where every data structure is\\npersistent (don’t confuse with\\n\", _jsx(_components.a, {\n        href: \"https://stackoverflow.com/questions/10034537/persistent-vs-immutable-data-structure\",\n        children: \"immutable\"\n      }), \").\\nIn Clojure, the same problem can be solved by defining the transaction\\nstructure as a persistent map.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"create\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-clojure\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title\",\n          children: \"ts\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":payment\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":currency\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \"\\n                   \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":amount\"\n        }), \"   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"}\\n         \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":parts\"\n        }), \"   {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":from\"\n        }), \" {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":id\"\n        }), \"   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \"\\n                          \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":name\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \"}\\n                   \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":to\"\n        }), \"   {\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":id\"\n        }), \"   \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \"\\n                          \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":name\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \"}}})\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Not as concise as Kotlin’s version, but still pretty good. What is\\ncompletely different to Kotlin, is the update function\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-clojure\",\n        children: [\"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"def\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title\",\n          children: \"ts2\"\n        }), \" (\", _jsx(_components.span, {\n          className: \"hljs-name\",\n          children: \"assoc-in\"\n        }), \" ts [\", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":parts\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":from\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-symbol\",\n          children: \":name\"\n        }), \"] \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s only one line! And it’s exactly what we aimed for. The next picture\\nmight be essential for understanding how it works.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain_clj.svg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Given that each node has a known type - \", _jsx(_components.code, {\n        children: \"clojure.lang.APersistentMap\"\n      }), \" -\\nand the universal way of traversing is \", _jsx(_components.code, {\n        children: \"map.get(\\\"key\\\")\"\n      }), \", it’s possible\\nto write a function \", _jsx(_components.code, {\n        children: \"assoc-in\"\n      }), \" which can change a value under a given\\n\\\"path\\\" and to recreate the data structure \", _jsx(_components.a, {\n        href: \"http://cjohansen.no/clojure-to-die-for/\",\n        children: \"node by\\nnode\"\n      }), \". But Clojure’s internals\\nare plain java classes that can be used from Kotlin easily just with a\\nfew \\\"convenience\\\" adapters to keep familiar syntax.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"create\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" tran = pArrayMap(\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"payment\\\"\"\n        }), \" to pArrayMap(\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"currency\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \",\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"amount\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \"\\n  ),\\n  \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parts\\\"\"\n        }), \" to pArrayMap(\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"from\\\"\"\n        }), \" to pArrayMap(\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \"\\n    ),\\n    \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"to\\\"\"\n        }), \" to pArrayMap(\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"id\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \",\\n      \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \" to \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \"\\n    )\\n  )\\n)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"Yes, the creation looks rather ugly. It’s untyped, all the key names are\\nrepresented as strings, but let’s look at the update function.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"update\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans2 = trans.pUpdate(listOf(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parts\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"from\\\"\"\n        }), \", \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"name\\\"\"\n        }), \"), \", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \")\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s still as concise and beautiful as Clojure’s one.\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But is it possible to build a DSL which keeps types from Kotlin types\\nand provides the conciseness of Clojure?\"\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"cursor-dsl\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#cursor-dsl\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Cursor DSL\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It is possible! Using a special DSL, you can define the structure of the\\n\\\"transactional\\\" domain in a following way.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Transaction\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cTransaction, F\u003e.payment \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node\u003cPayment\u003e()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cTransaction, F\u003e.parts \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node\u003cParts\u003e()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Payment\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cPayment, F\u003e.currency \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf\u003cString\u003e()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cPayment, F\u003e.amount \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf\u003c\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \"\u003e()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Parts\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cParts, F\u003e.to \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node\u003cPerson\u003e()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cParts, F\u003e.from \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node\u003cPerson\u003e()\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cPerson, F\u003e.id \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf\u003c\", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Int\"\n        }), \"\u003e()\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cPerson, F\u003e.name \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf\u003cString\u003e()\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"This looks scary, but it’s just a bit of necessary boilerplate. This\\ncode should be read like\"\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The creation looks very similar to the untyped version, but it’s\\ncompletely typed. It references properties defined above.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans = domain\u003cTransaction\u003e {\\n  (payment) {\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \")\\n  }\\n  (parts) {\\n    (from) {\\n      id.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"0\"\n        }), \")\\n      name.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Alex\\\"\"\n        }), \")\\n    }\\n    (to) {\\n      id.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"1\"\n        }), \")\\n      name.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"Ben\\\"\"\n        }), \")\\n    }\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"It’s possible to update the transaction easily. And not just one field,\\nin fact, the code above creates an empty data structure and applies an\\nupdate function to it.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans2 = trans.cursor.parts.from.update {\\n  name.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"John\\\"\"\n        }), \")\\n}\\nprintln(trans.cursor.parts.from.name.value) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"Alex\\\"\"\n        }), \"\\nprintln(trans2.cursor.parts.from.name.value) \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \\\"John\\\"\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"or\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" trans3 = trans2.cursor.update {\\n  (payment) {\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"USD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"12\"\n        }), \")\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"What is really awesome is that the \", _jsx(_components.code, {\n        children: \"set\"\n      }), \" function can only be called\\ninside the \", _jsx(_components.code, {\n        children: \"update\"\n      }), \" block. It’s possible to think about the \", _jsx(_components.code, {\n        children: \"update\"\n      }), \"\\nblock as an open transaction where a few updates are applied.\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"implementation\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#implementation\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Implementation\"]\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"read\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#read\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Read\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The easiest way to start implementing it is to imagine that the data\\nstructure is already created and everything we need to do is to read a\\nvalue from it. The obvious untyped solution will be to call\\n\", _jsx(_components.code, {\n        children: \"trans.get(\\\"parts\\\").get(\\\"from\\\").get(\\\"name\\\")\"\n      }), \". And this approach works\\nfine until we need to update it. After the first \", _jsx(_components.code, {\n        children: \"get\"\n      }), \" call, the\\nreference to the root transaction is lost and there’ll be no way to run\\nthe update operation.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Instead, it’s possible to focus on the way of traversing the data\\nstructure without loosing the reference to the root. To accomplish this,\\nit’s possible to implement \", _jsx(_components.code, {\n        children: \"Focus\"\n      }), \" interface which holds the reference\\nto the root and accumulates a path inside.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Focus\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out Op\"\n        }), \"\u003e {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"narrow\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Focus\u003cOp\u003e\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" op: Op\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The interesting thing that \", _jsx(_components.code, {\n        children: \"Focus\"\n      }), \" is parametrised over an operation.\\nThat operation can be \", _jsx(_components.code, {\n        children: \"Read\"\n      }), \" or \", _jsx(_components.code, {\n        children: \"Write\"\n      }), \" depending on the context. When a\\nleaf is reached, the typed version will finally perform an action using\\nthat operation.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"narrow down the usage\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f = Focus(trans)       \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// {\\\"root\\\" -\u003e Transaction, path -\u003e []}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f2 = f.narrow(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"parts\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// {\\\"root\\\" -\u003e Transaction, path -\u003e [\\\"parts\\\"]}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f3 = f2.narrow(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"from\\\"\"\n        }), \") \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// {\\\"root\\\" -\u003e Transaction, path -\u003e [\\\"parts\\\", \\\"from\\\"]}\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ...\"\n        }), \"\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain_focus.svg\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"But even though the focus does its job very well, it’s completely\\nuntyped, and strings have to be used to navigate through. The type must\\nbe stored somewhere. As everyone knows that any problem can be solved\\nwith an additional layer of abstraction! Let’s define a wrapper\\nparametrised over the type of an underlying node.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"the missed layer\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Cursor\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T, out Op\"\n        }), \"\u003e(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" f: Focus\u003cOp\u003e)\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Cursor\"\n      }), \" is parametrised over a node type and the \", _jsx(_components.code, {\n        children: \"operation\"\n      }), \" is derived\\nfrom the focus. And now, the \", _jsx(_components.code, {\n        children: \"Transaction\"\n      }), \" definition starts making\\nsense. The narrowing can be delegated to the \", _jsx(_components.code, {\n        children: \"Node\"\n      }), \" object that knows\\nthe type and uses the name of a property to create a new \", _jsx(_components.code, {\n        children: \"Cursor\"\n      }), \" with a\\nnew \", _jsx(_components.code, {\n        children: \"Focus\"\n      }), \" inside.\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Transaction\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cTransaction, F\u003e.payment \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Node\u003cPayment\u003e()\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Here, the \", _jsx(_components.code, {\n        children: \"payment\"\n      }), \" is an extension property on the \", _jsx(_components.code, {\n        children: \"Transaction\"\n      }), \" type\\nwhich is just a marker interface. It will never be instantiated, instead\\nby delegating property to \", _jsx(_components.code, {\n        children: \"Node\u003cPayment\u003e\"\n      }), \", the conversion\\n\", _jsx(_components.code, {\n        children: \"Cursor\u003cTransacton, F\u003e =\u003e Cursor\u003cPayment, F\u003e\"\n      }), \" will be made.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"how Node is defined\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Node\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T\"\n        }), \"\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cOp\u003e\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getValue\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(ref: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"\u003c*, Op\u003e, property: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"KProperty\"\n            }), \"\u003c*\u003e)\"]\n          })]\n        }), \": Cursor\u003cT, Op\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Cursor(ref.f.narrow(property.name))\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Inside \", _jsx(_components.code, {\n        children: \"Node\"\n      }), \", a new Cursor is created with the focus narrowing down\\nusing a property name. Using this technique, by just calling extension\\nproperties a focus can narrow down to the last node where the last node\\nis delegated to \", _jsx(_components.code, {\n        children: \"Leaf\"\n      }), \" instead of \", _jsx(_components.code, {\n        children: \"Node\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Person\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cF\u003e Cursor\u003cPerson, F\u003e.name \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"by\"\n        }), \" Leaf\u003cString\u003e()\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [_jsx(_components.code, {\n        children: \"Leaf\u003cV\u003e\"\n      }), \" is defined in the same way as Node except for the return value\\nof \", _jsx(_components.code, {\n        children: \"getValue\"\n      }), \".\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Leaf\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out V\"\n        }), \"\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"open\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cOp\u003e\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getValue\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(ref: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"\u003c*, Op\u003e, property: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"KProperty\"\n            }), \"\u003c*\u003e)\"]\n          })]\n        }), \": Cursor\u003cLeaf\u003cV\u003e, Op\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Cursor(ref.f.narrow(property.name))\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Leaf is needed to define an extension property that allows reading a\\nvalue from that node. The property has the following signature\\n\", _jsx(_components.code, {\n        children: \"val \u003cV, T\u003e Cursor\u003cLeaf\u003cV\u003e, Read\u003cT\u003e\u003e.value: V\"\n      }), \" which says: given the\\ncursor focused on a leaf and parametrised over a read operation, provide\\na value contained by the leaf.\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: _jsx(_components.img, {\n        src: \"/images/fantastic/domain_red.png\",\n        alt: \"\"\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"The remaining logic is described below\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// the main data structure where T type - is the root type\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// in our case, T is Transaction.\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// root is just an empty persisntent map\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Domain\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T\"\n        }), \"\u003e(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" root: PMap = PHashMap.EMPTY)\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// The read operation that focus owns (Op)\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Read\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out M\"\n        }), \"\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" path: Path         \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// path to the current node (ex. [\\\"payment\\\", \\\"currency\\\"])\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" domain: Domain\u003cM\u003e  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// the reference to the root\"\n        }), \"\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// the implementation of the focus\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Reader\"\n        }), \"\u003c\", _jsx(_components.span, {\n          className: \"hljs-type\",\n          children: \"out T\"\n        }), \"\u003e(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" p: Path, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" dm: Domain\u003cT\u003e) : Focus\u003cRead\u003cT\u003e\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// this is how narrowing happens, just extend the path and keep the refernce to the root\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"narrow\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Focus\u003cRead\u003cT\u003e\u003e = Reader(p.append(k), dm)\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" op: Read\u003cT\u003e = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"object\"\n        }), \" : Read\u003cT\u003e {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" domain: Domain\u003cT\u003e = dm\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" path: Path = p\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// take a focus, take a read operation from it and ask for value\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// by traversing the root using path\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cV, T\u003e Cursor\u003cLeaf\u003cV\u003e, Read\u003cT\u003e\u003e.value: V\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"() = f.op.path.getIn(f.op.domain.root) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" V\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// this is how cursor get's created, emtpy path and reference to the root\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" \u003cT\u003e Domain\u003cT\u003e.cursor: Cursor\u003cT, Read\u003cT\u003e\u003e\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"get\"\n        }), \"() = Cursor(Reader(Path.EMPTY, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"this\"\n        }), \"))\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.h4, {\n      id: \"update\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#update\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Update\"]\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"So far we can traverse the data structure and read values from it. The\\nnext step is to learn how to update it. Problems start when we realise\\nthat the underlying data structure is persistent and there is no way to\\nmutate it. To emulate mutation, a special wrapper has to be defined. It\\nreassigns the reference after each mutation.\"\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"immutable ⇒ mutable\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Mutable\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"var\"\n        }), \" m: PMap) {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"write\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(p: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Path\"\n            }), \", a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \" {\\n    m = p.assocIn(m, a)\\n  }\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"read\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(p: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Path\"\n            }), \")\"]\n          })]\n        }), \" = p.getIn(m)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Then, we’ll need to implement the \", _jsx(_components.code, {\n        children: \"Write\"\n      }), \" operation which supports\\nreading and writing under a specific path. At first glance, \", _jsx(_components.code, {\n        children: \"read\"\n      }), \"\\noperation is unnecessary, but it’s needed to read the final result after\\nall modification were applied using an empty path. Another application\\nof the \", _jsx(_components.code, {\n        children: \"read()\"\n      }), \" operation is node initialisation. E.g. if you create an\\nempty domain and decide to write a value to leaf using a cursor, all the\\nparent nodes need to be initialised first.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsxs(_components.strong, {\n          children: [\"Op for \", _jsx(_components.code, {\n            children: \"Cursor\u003cT, Write\u003e\"\n          })]\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"interface\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Write\"\n        }), \" {\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"read\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": Any?\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"write\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \"\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And the corresponding cursor\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"WriterCursor\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" m: Mutable, \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" path: Path) : Focus\u003cWrite\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// exactly the same narrowing pattern\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"narrow\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Focus\u003cWrite\u003e = WriterCursor(m, path.append(k))\\n\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" op: Write = \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"object\"\n        }), \" : Write {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"write\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \" = m.write(path, a)\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"override\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"read\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          })]\n        }), \": Any? = m.read(path)\\n  }\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"And at some point in time, we might want to switch from the \", _jsx(_components.code, {\n        children: \"Read\"\n      }), \"\\ncursor to the \", _jsx(_components.code, {\n        children: \"Write\"\n      }), \" cursor. For that, a special function exists.\"]\n    }), \"\\n\", _jsx(\"div\", {\n      class: \"formalpara-title\",\n      children: _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"Cursor\u003cT, Read\u003e ⇒ Cursor\u003cT, Write\u003e\"\n        })\n      })\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cT, M\u003e\"\n          }), \" Cursor\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cM, Read\u003cT\u003e\"\n          }), \"\u003e.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"update\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(update: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"\u003c\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"M\"\n            }), \", Write\u003e.()\"]\n          })]\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \"): Domain\u003cT\u003e {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// take a root, make a mutable from it\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" m = Mutable(f.op.domain.root)\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// create a writer from mutable and apply `update` supplied from outside\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// exactly the same pattern as any other DSL has\"\n        }), \"\\n  Cursor\u003cM, Write\u003e(WriterCursor(m, f.op.path)).update()\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// read the final value from the root and return a new instance of Domain\"\n        }), \"\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"return\"\n        }), \" Domain(m.read(Path.EMPTY) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" PMap)\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// to simplify the initialisation\"\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cM\u003e\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"domain\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(f: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"\u003c\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"M\"\n            }), \", Write\u003e.()\"]\n          })]\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \") = Domain\u003cM\u003e().cursor.update(f)\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And finally, a set of public typed operation that API consumers use\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// for each leaf initial value is null\"\n        }), \"\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// for each node initial value is empty persistent map\"\n        }), \"\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" Write.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"init\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(k: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"KClass\"\n            }), \"\u003c*\u003e)\"]\n          })]\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"if\"\n        }), \" (read() == \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \") {\\n    write(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"when\"\n        }), \" (k) {\\n      Leaf::\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-literal\",\n          children: \"null\"\n        }), \"\\n      \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"else\"\n        }), \" -\u003e PArrayMap.EMPTY\\n    })\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"operator\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"inline\"\n        }), \" \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsxs(_components.span, {\n            className: \"hljs-type\",\n            children: [\"\u003c\", _jsx(_components.span, {\n              className: \"hljs-keyword\",\n              children: \"reified\"\n            }), \" T\u003e\"]\n          }), \" Cursor\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cT, Write\u003e\"\n          }), \".\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"invoke\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\\n    updateFn: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Cursor\"\n            }), \"\u003c\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \", Write\u003e.()\"]\n          })]\n        }), \" -\u003e \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \"): \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// init the current node (it might be null if we haven't visited it before)\"\n        }), \"\\n  f.op.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"init\"\n        }), \"(T::\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \")\\n  updateFn()\\n}\\n\\n\", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cT\u003e\"\n          }), \" Cursor\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"\u003cLeaf\u003cT\u003e\"\n          }), \", Write\u003e.\", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"set\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(t: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"T\"\n            }), \")\"]\n          })]\n        }), \": \", _jsx(_components.span, {\n          className: \"hljs-built_in\",\n          children: \"Unit\"\n        }), \" {\\n  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// just delegate to write\"\n        }), \"\\n  f.op.write(t)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"The \", _jsx(_components.code, {\n        children: \"invoke\"\n      }), \" function is responsible for Node initialisation whereas\\n\", _jsx(_components.code, {\n        children: \"set\"\n      }), \" sets the Leaf’s value\"]\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [\"domain\u003cTransaction\u003e {\\n  (payment) {  \", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// \u003c- here invoke is called\"\n        }), \"\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \")\\n  }\\n}\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-comment\",\n          children: \"// ↑ is equal to the desugarised version ↓\"\n        }), \"\\ndomain\u003cTransaction\u003e {\\n  payment.invoke({\\n    currency.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-string\",\n          children: \"\\\"AUD\\\"\"\n        }), \")\\n    amount.\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"set\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-number\",\n          children: \"15\"\n        }), \")\\n  })\\n}\\n\"]\n      })\n    }), \"\\n\", _jsx(_components.p, {\n      children: \"And at the end, a Path that does all the work, but in fact, it does\\nnothing except for delegating functionality to functions from Clojure\\nthat do all the work on untyped persistent data structures.\"\n    }), \"\\n\", _jsx(_components.pre, {\n      children: _jsxs(_components.code, {\n        className: \"hljs language-kotlin\",\n        children: [_jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" clojure.`core$assoc_in` \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" assocIn\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" clojure.`core$get_in` \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" getIn\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"import\"\n        }), \" clojure.lang.*\\n\\n\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"data\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"class\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-title class_\",\n          children: \"Path\"\n        }), \"(\", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"private\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" v: APersistentVector) {\\n  \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"companion\"\n        }), \" \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"object\"\n        }), \" {\\n    \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"val\"\n        }), \" EMPTY = Path(PersistentVector.EMPTY)\\n  }\\n\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"append\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"String\"\n            }), \")\"]\n          })]\n        }), \": Path = Path(v.cons(a) \", _jsx(_components.span, {\n          className: \"hljs-keyword\",\n          children: \"as\"\n        }), \" APersistentVector)\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"getIn\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(model: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \": Any? = getIn.invokeStatic(model, v)\\n  \", _jsxs(_components.span, {\n          className: \"hljs-function\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"fun\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title\",\n            children: \"assocIn\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(m: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?, a: \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"Any\"\n            }), \"?)\"]\n          })]\n        }), \": Any? = assocIn.invokeStatic(m, v, a)\\n}\\n\"]\n      })\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"Using these primitives, we built a really powerful type safe DSL to work\\non immutable data structures. Yes, it has a few downsides. E.g. data\\nclasses solution has better performance. And most of the time it’s\\nconcise enough, unless you have a really deeply nested tree. In that\\ncase, you might also try to use \", _jsx(_components.a, {\n        href: \"https://www.schoolofhaskell.com/school/to-infinity-and-beyond/pick-of-the-week/basic-lensing\",\n        children: \"the lenses\\npattern\"\n      }), \"\\nwhich comes from the functional world and solves the same problem. But\\nif you already have untyped data structures in your project and have to\\nwork with them, Kotlin provides a truly unique set of features that\\nallows you to build a powerful DSL to make your life safer and easier.\"]\n    }), \"\\n\", _jsxs(_components.p, {\n      children: [\"It’s very probable that some parts of the solution shown above might\\nstill be unclear, in that case, I encourage you to clone \", _jsx(_components.a, {\n        href: \"https://github.com/SerCeMan/talk-fantastic-dsls-example\",\n        children: \"the code\\nexample\"\n      }), \" in\\nyour IDE, run it and try to play with types. It will help a lot and can\\ngive you some interesting ideas on how advanced Kotlin features can be\\nused.\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"conclusions\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#conclusions\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Conclusions\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Kotlin provides many unique features to build DSLs easily\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"DSLs in Kotlin work best as configuration APIs\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"They can be a powerful abstraction over untyped data structures\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h3, {\n      id: \"warnings\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#warnings\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Warnings\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Most of the time plain code is better than DSL\\nThere is no point in building DSL \\\"just because I can\\\", plain Kotlin\\ncode is often much easier to read and understand.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Provide a way to extend and bypass your DSL\\nIf you publish DSL as a part of your API, it’s always a good idea to\\ngive a way to bypass or extend it. Of course, if it’s a Gradle-like\\nDSL then you can cover everything. But in the case of a html DSL, a\\nuser might want to introduce some tags that your DSL doesn’t support.\\nOr, he can have an already rendered string which needs to be inserted\\nsomewhere.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"links\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#links\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Links\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: _jsx(_components.a, {\n            href: \"https://github.com/SerCeMan/talk-fantastic-dsls-example\",\n            children: \"Cursor DSL source\\ncode\"\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Why you should use DSLs: \", _jsx(_components.a, {\n            href: \"http://jonnyzzz.com/blog/2016/09/02/dsl-building/\",\n            children: \"Building DSL Instead of an IDE\\nPlugin\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Why you shouldn’t: \", _jsx(_components.a, {\n            href: \"https://victor.kropp.name/blog/kotlin-dsls-good-bad-and-ugly/\",\n            children: \"DSLs in Kotlin: The Good, the Bad and the\\nUgly\"\n          })]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"thanks\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#thanks\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Thanks\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"Kotlin team for creating an awesome language!\\nPlease, press a ★ button on the \", _jsx(_components.a, {\n            href: \"https://github.com/JetBrains/kotlin\",\n            children: \"Kotlin’s GitHub\\nrepo\"\n          }), \" if you haven’t done it yet.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [_jsx(_components.a, {\n            href: \"https://twitter.com/jetzajac\",\n            children: \"@JetZajac\"\n          }), \" who initially came up with\\nthe idea of persistent data structure based DSLs\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You for reading it\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsxs(_components.h2, {\n      id: \"share-this-article\",\n      children: [_jsx(_components.a, {\n        className: \"anchor\",\n        href: \"#share-this-article\",\n        children: _jsx(_components.span, {\n          className: \"icon icon-link\"\n        })\n      }), \"Share this article\"]\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://twitter.com/SerCeMan/status/880365305314254848\",\n          children: \"Twitter\"\n        })\n      }), \"\\n\", _jsx(_components.li, {\n        children: _jsx(_components.a, {\n          href: \"https://news.ycombinator.com/item?id=14663115\",\n          children: \"Hacker News\"\n        })\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"title":"Fantastic DSLs and where to find them","description":"Empty","date":"2017-06-29"}},"frontMatter":{"title":"Fantastic DSLs and where to find them","description":"Empty","date":"2017-06-29"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"29-06-2017-fantastic-dsls"},"buildId":"3sWW6Mm9mumttKqNI3vIa","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>